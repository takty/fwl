{
  "version": 3,
  "sources": ["../node_modules/stlics/src/problem/element.ts", "../node_modules/stlics/src/problem/variable.ts", "../node_modules/stlics/src/problem/domain.ts", "../node_modules/stlics/src/problem/constraint.ts", "../node_modules/stlics/src/problem/problem.ts", "../node_modules/stlics/src/solver/monitor.ts", "../node_modules/stlics/src/solver/solver.ts", "../node_modules/stlics/src/solver/misc/assignment.ts", "../node_modules/stlics/src/solver/misc/random.ts", "../node_modules/stlics/src/solver/misc/assignment-list.ts", "../node_modules/stlics/src/solver/misc/consistency.ts", "../node_modules/stlics/src/solver/fuzzy/flexible-local-changes.ts", "../node_modules/stlics/src/solver/misc/domain-pruner.ts", "../node_modules/stlics/src/util/variables.ts", "../node_modules/stlics/src/util/relations.ts", "../node_modules/stlics/src/util/problems.ts", "../node_modules/stlics/src/solver/fuzzy/full-checking.ts", "../node_modules/stlics/src/solver/fuzzy/fuzzy-breakout.ts", "../node_modules/stlics/src/solver/fuzzy/fuzzy-forward-checking.ts", "../node_modules/stlics/src/solver/fuzzy/fuzzy-genet.ts", "../node_modules/stlics/src/solver/fuzzy/srs3.ts", "../node_modules/stlics/src/solver/crisp/breakout.ts", "../node_modules/stlics/src/solver/crisp/crisp-srs3.ts", "../node_modules/stlics/src/solver/crisp/forward-checking.ts", "../node_modules/stlics/src/solver/crisp/genet.ts", "../node_modules/stlics/src/solver/crisp/local-changes.ts", "../node_modules/stlics/src/solver/crisp/max-forward-checking.ts", "../src/control/control.ts", "../src/control/button.ts", "../src/control/checkbox.ts", "../src/control/checkboxes.ts", "../src/control/label.ts", "../src/control/list-box.ts", "../src/control/radio-buttons.ts", "../src/layout/layout.ts", "../node_modules/stlics/stlics.ts", "../node_modules/stlics/src/solver/filter/post-stabilizer.ts", "../src/f-element.ts", "../src/f-layout.ts", "../src/layout/array-horizontal.ts", "../src/layout/array-vertical.ts", "../src/layout/labeling-left.ts", "../src/layout/labeling-top.ts", "../src/f-control.ts", "../src/f-control-caption.ts", "../src/f-control-multiple.ts", "../src/f-control-single.ts", "../src/f-control-single-boolean.ts", "../src/f-layout-array.ts", "../src/f-layout-labeling.ts", "../src/flexible-layout.ts"],
  "sourcesContent": ["/**\n * The common class of variables and constraints.\n *\n * @author Takuto Yanagida\n * @version 2025-01-02\n */\n\nexport class Element {\n\n\t#index: number = -1;\n\t#name : string = '';\n\n\t/**\n\t * It is used when the user wishes to associate an arbitrary object with each element.\n\t */\n\tuserObject: any = null;\n\n\t// Called only from Problem.\n\tsetIndex(index: number): void {\n\t\tthis.#index = index;\n\t}\n\n\t/**\n\t * Sets the name.\n\t *\n\t * @param name string representing the name.\n\t */\n\tsetName(name: string): void {\n\t\tthis.#name = name;\n\t}\n\n\t/**\n\t * Get the index on the owned problem.\n\t * Each variable and constraint is assigned a serial number as an index, which is used to access it through the problem.\n\t *\n\t * @return Integer value representing the index.\n\t */\n\tindex(): number {\n\t\treturn this.#index;\n\t}\n\n\t/**\n\t * Gets the name.\n\t *\n\t * @return String representing the name.\n\t */\n\tname(): string {\n\t\treturn this.#name;\n\t}\n\n}\n", "/**\n * The class that represents a variable.\n *\n * @author Takuto Yanagida\n * @version 2025-01-24\n */\n\nimport { Element } from './element';\nimport { Domain } from './domain';\nimport { Constraint } from './constraint';\n\nexport class Variable extends Element {\n\n\tstatic readonly #INVALID: number = Number.MIN_VALUE;\n\n\tprotected d : Domain;\n\tprotected es: Constraint[] = [];\n\n\tprotected v: number = Variable.#INVALID;\n\n\t// Called only from Problem.\n\tconstructor(d: Domain) {\n\t\tsuper();\n\t\tthis.d = d;\n\t}\n\n\t/**\n\t * Gets a string representation.\n\t * @return A string representation.\n\t */\n\toverride toString(): string {\n\t\tconst n : string = this.name();\n\t\tconst np: string = n ? `(${n})` : '';\n\t\tconst sn: string = this.isEmpty() ? '<empty>' : ('' + this.value());\n\n\t\treturn `x${this.index()}${np} = ${sn}`;\n\t}\n\n\t/**\n\t * Gets the number of associated constraints.\n\t * @return Number of constraints.\n\t */\n\tsize(): number {\n\t\treturn this.es.length;\n\t}\n\n\t/**\n\t * Gets the associated constraint by specifying its index.\n\t * @param index Index.\n\t * @return A constraint.\n\t */\n\tat(index: number): Constraint | undefined {\n\t\treturn this.es.at(index);\n\t}\n\n\t/**\n\t * Checks whether or not the specified constraint is associated.\n\t * @param c A constraint.\n\t * @return True if associated.\n\t */\n\thas(c: Constraint): boolean {\n\t\treturn this.es.includes(c);\n\t}\n\n\t/**\n\t * Gets the index of a specified constraint.\n\t * If not found, returns -1.\n\t * @param c A constraint.\n\t * @return Index.\n\t */\n\tindexOf(c: Constraint): number {\n\t\treturn this.es.indexOf(c);\n\t}\n\n\t/**\n\t * Collects the variables connected via the associated constraints.\n\t * @return An array of variables\n\t */\n\tneighbors(): Variable[] {\n\t\tconst xs: Variable[] = [];\n\n\t\tfor (const c of this.es) {\n\t\t\tfor (const x of c) {\n\t\t\t\tif (x !== this) {\n\t\t\t\t\txs.push(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn xs;\n\t}\n\n\t/**\n\t * Gets the iterator of the associated constraints.\n\t */\n\t[Symbol.iterator](): Iterator<Constraint> {\n\t\treturn this.es[Symbol.iterator]();\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t// Called only from Problem.\n\tconnect(c: Constraint): void {\n\t\tif (this.es.includes(c)) {\n\t\t\tthrow new RangeError();\n\t\t}\n\t\tthis.es.push(c);\n\t}\n\n\t// Called only from Problem.\n\tdisconnect(c: Constraint): void {\n\t\tif (!this.es.includes(c)) {\n\t\t\tthrow new RangeError();\n\t\t}\n\t\tthis.es = this.es.filter(\n\t\t\t(i: Constraint): boolean => i !== c\n\t\t);\n\t}\n\n\t/**\n\t * Gets the domain of the variable.\n\t * @return The domain.\n\t */\n\tdomain(): Domain;\n\n\t/**\n\t * Sets a new domain to the variable.\n\t * The variable will be in unassigned state.\n\t * @param d Domain to be assigned.\n\t */\n\tdomain(d: Domain): void;\n\n\tdomain(d?: Domain): Domain | void {\n\t\tif (d === undefined) {\n\t\t\treturn this.d;\n\t\t} else {\n\t\t\tthis.d = d;\n\t\t\tthis.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Assign a value.\n\t * @param value Value.\n\t */\n\tassign(value: number): void {\n\t\tthis.v = value;  // Do not change #val except here.\n\t}\n\n\t/**\n\t * Sets the state of the variable to unassigned.\n\t */\n\tclear(): void {\n\t\t// Do not use the invalid value except here and below (isEmpty).\n\t\tthis.assign(Variable.#INVALID);\n\t}\n\n\t/**\n\t * Gets the value of the variable.\n\t * @returnThe value of the variable.\n\t */\n\tvalue(): number {\n\t\treturn this.v;\n\t}\n\n\t/**\n\t * Checks whether the value is unassigned or not.\n\t * @return True if unassigned.\n\t */\n\tisEmpty(): boolean {\n\t\treturn this.value() === Variable.#INVALID;\n\t}\n\n}\n", "/**\n * An abstract class that represents a variable domain.\n * The domain is immutable.\n *\n * @author Takuto Yanagida\n * @version 2025-01-24\n */\n\nexport abstract class Domain {\n\n\t/**\n\t * Generates a domain.\n\t * @param vs Multiple values.\n\t * @return A domain.\n\t */\n\tstatic create(vs: number[]): Domain;\n\n\t/**\n\t * Generates a domain.\n\t * @param min Minimum value.\n\t * @param max Maximum value.\n\t * @return A domain.\n\t */\n\tstatic create(min: number, max: number): Domain;\n\n\tstatic create(vs_min: number[] | number, max: number | null = null): Domain {\n\t\tif (Array.isArray(vs_min)) {\n\t\t\treturn new DomainArbitrary(vs_min);\n\t\t} else if (null !== max) {\n\t\t\treturn new DomainRanged(vs_min, max);\n\t\t}\n\t\tthrow new RangeError();\n\t}\n\n\t/**\n\t * Checks whether the specified value is included as an element of the domain.\n\t *\n\t * @param v A value.\n\t * @return True if the value is included.\n\t */\n\tabstract contains(v: number): boolean;\n\n\t/**\n\t * Gets the index of the specified value. If it does not exist, -1 is returned.\n\t *\n\t * @param v A value.\n\t * @return The index.\n\t */\n\tabstract indexOf(v: number): number;\n\n\t/**\n\t * Gets the size of the domain, including the pruned elements.\n\t *\n\t * @return The size.\n\t */\n\tabstract size(): number;\n\n\t/**\n\t * Gets the value at the specified index. The retrieved value may have been pruned.\n\t *\n\t * @param index An index.\n\t * @return The value.\n\t */\n\tabstract at(index: number): number;\n\n\t/**\n\t * Gets the iterator of the values of the domain.\n\t */\n\tabstract [Symbol.iterator](): Iterator<number>;\n\n}\n\n\n// -----------------------------------------------------------------------------\n\n\nclass DomainArbitrary extends Domain {\n\n\t#vs: number[];\n\n\tconstructor(vs: number[]) {\n\t\tsuper();\n\t\tthis.#vs = [...vs];\n\t}\n\n\tcontains(v: number): boolean {\n\t\treturn this.#vs.includes(v);\n\t}\n\n\tindexOf(v: number): number {\n\t\treturn this.#vs.indexOf(v);\n\t}\n\n\tsize(): number {\n\t\treturn this.#vs.length;\n\t}\n\n\tat(index: number): number {\n\t\treturn this.#vs[index];\n\t}\n\n\t[Symbol.iterator](): Iterator<number> {\n\t\treturn this.#vs[Symbol.iterator]();\n\t}\n\n}\n\n\n// -----------------------------------------------------------------------------\n\n\nclass DomainRanged extends Domain {\n\n\t#min: number;\n\t#max: number;\n\n\tconstructor(min: number, max: number) {\n\t\tsuper();\n\t\tthis.#min = min | 0;\n\t\tthis.#max = max | 0;\n\t}\n\n\tcontains(v: number): boolean {\n\t\treturn this.#min <= v && v <= this.#max;\n\t}\n\n\tindexOf(v: number): number {\n\t\treturn (this.#min <= v && v <= this.#max) ? (v - this.#min) : -1;\n\t}\n\n\tsize(): number {\n\t\treturn this.#max - this.#min + 1;\n\t}\n\n\tat(index: number): number {\n\t\treturn this.#min + index;\n\t}\n\n\t[Symbol.iterator](): Iterator<number> {\n\t\tlet v: number = this.#min;\n\t\tconst max: number = this.#max;\n\t\treturn {\n\t\t\tnext(): IteratorResult<number> {\n\t\t\t\tif (v <= max) {\n\t\t\t\t\treturn { value: v++, done: false };\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: null, done: true };\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t}\n\n}\n", "/**\n * The class that represents a constraint.\n *\n * @author Takuto Yanagida\n * @version 2025-01-24\n */\n\nimport { Element } from './element';\nimport { Variable } from './variable';\n\nexport abstract class Constraint extends Element {\n\n\t// Called only from Problem.\n\tstatic create(r: (...vs: number[]) => number, xs: Variable[]): Constraint {\n\t\tif (1 === xs.length) {\n\t\t\treturn new Constraint1(r, xs[0]);\n\t\t}\n\t\tif (2 === xs.length) {\n\t\t\treturn new Constraint2(r, xs[0], xs[1]);\n\t\t}\n\t\tif (3 === xs.length) {\n\t\t\treturn new Constraint3(r, xs[0], xs[1], xs[2]);\n\t\t}\n\t\treturn new ConstraintN(r, ...xs);\n\t}\n\n\tprotected r : (...vs: number[]) => number;  // Relation\n\tprotected es: Variable[] = [];\n\n\tprotected constructor(r: (...vs: number[]) => number) {\n\t\tsuper();\n\t\tthis.r = r;\n\t}\n\n\t/**\n\t * Gets a string representation.\n\t * @return A string representation.\n\t */\n\toverride toString(): string {\n\t\tconst n : string = this.name();\n\t\tconst np: string = n ? `(${n})` : '';\n\t\tconst ev: number = this.degree();\n\t\tconst sn: string = ev < 0 /* ev === UNDEFINED */ ? 'UNDEFINED' : ('' + ev);\n\n\t\treturn `c${this.index()}${np} = ${sn}`;\n\t}\n\n\t/**\n\t * Gets the order of the constraint, i.e., the number of (associated) variables in the scope.\n\t * @return Order.\n\t */\n\tsize(): number {\n\t\treturn this.es.length;\n\t}\n\n\t/**\n\t * Gets the associated variable by specifying its index.\n\t * @param index Index.\n\t * @return A variable.\n\t */\n\tat(index: number): Variable | undefined {\n\t\treturn this.es.at(index);\n\t}\n\n\t/**\n\t * Checks whether or not the specified variable is associated.\n\t * @param x A variable.\n\t * @return True if associated.\n\t */\n\thas(x: Variable): boolean {\n\t\treturn this.es.includes(x);\n\t}\n\n\t/**\n\t * Gets the index of a specified variable.\n\t * If not found, returns -1.\n\t * @param x A variable.\n\t * @return Index.\n\t */\n\tindexOf(x: Variable): number {\n\t\treturn this.es.indexOf(x);\n\t}\n\n\t/**\n\t * Collects the constraints connected via the associated variables.\n\t * @return An array of constraints.\n\t */\n\tneighbors(): Constraint[] {\n\t\tconst cs: Constraint[] = [];\n\n\t\tfor (const x of this.es) {\n\t\t\tfor (const c of x) {\n\t\t\t\tif (c !== this) {\n\t\t\t\t\tcs.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cs;\n\t}\n\n\t/**\n\t * Gets the iterator of the associated variables.\n\t */\n\t[Symbol.iterator](): Iterator<Variable> {\n\t\treturn this.es[Symbol.iterator]();\n\t}\n\n\n\t// ----\n\n\n\t/**\n\t * Returns the relation between variables.\n\t * @return Relation.\n\t */\n\trelation(): (...vs: number[]) => number {\n\t\treturn this.r;\n\t}\n\n\t/**\n\t * Returns the number of scope variables that have not been assigned a value.\n\t * @return Number of variables\n\t */\n\tabstract emptySize(): number;\n\n\t/**\n\t * Returns whether or not the satisfaction (degree) is defined.\n\t * Satisfaction (degree) is defined when all associated variables have values assigned to them.\n\t * @return True if it is defined.\n\t */\n\tabstract isDefined(): boolean;\n\n\t/**\n\t * Returns whether or not this constraint is satisfied.\n\t * @return 1 if satisfied, 0 if not, UNDEFINED if undefined\n\t */\n\tabstract status(): -1 | 0 | 1;\n\n\t/**\n\t * Gets the current satisfaction degree.\n\t * @return Degree 0 - 1, UNDEFINED if undefined.\n\t */\n\tabstract degree(): number;\n\n}\n\n\n// -----------------------------------------------------------------------------\n\n\nclass Constraint1 extends Constraint {\n\n\tconstructor(r: (v0: number) => number, x: Variable) {\n\t\tsuper(r);\n\t\tthis.es = [x];\n\t}\n\n\temptySize(): number {\n\t\treturn this.es[0].isEmpty() ? 1 : 0;\n\t}\n\n\tisDefined(): boolean {\n\t\treturn !this.es[0].isEmpty();\n\t}\n\n\tstatus(): -1 | 0 | 1 {\n\t\tif (this.es[0].isEmpty()) {\n\t\t\treturn -1;  // UNDEFINED\n\t\t}\n\t\treturn 1 === this.r(this.es[0].value()) ? 1 : 0;\n\t}\n\n\tdegree(): number {\n\t\tif (this.es[0].isEmpty()) {\n\t\t\treturn -1;  // UNDEFINED\n\t\t}\n\t\treturn this.r(this.es[0].value());\n\t}\n\n}\n\n\n// -----------------------------------------------------------------------------\n\n\nclass Constraint2 extends Constraint {\n\n\tconstructor(r: (v0: number, v1: number) => number, x1: Variable, x2: Variable) {\n\t\tsuper(r);\n\t\tthis.es = [x1, x2];\n\t}\n\n\temptySize(): number {\n\t\tlet n: number = 0;\n\t\tif (this.es[0].isEmpty()) ++n;\n\t\tif (this.es[1].isEmpty()) ++n;\n\t\treturn n;\n\t}\n\n\tisDefined(): boolean {\n\t\treturn !this.es[0].isEmpty() && !this.es[1].isEmpty();\n\t}\n\n\tstatus(): -1 | 0 | 1 {\n\t\tif (this.es[0].isEmpty() || this.es[1].isEmpty()) {\n\t\t\treturn -1;  // UNDEFINED\n\t\t}\n\t\treturn 1 === this.r(this.es[0].value(), this.es[1].value()) ? 1 : 0;\n\t}\n\n\tdegree(): number {\n\t\tif (this.es[0].isEmpty() || this.es[1].isEmpty()) {\n\t\t\treturn -1;  // UNDEFINED\n\t\t}\n\t\treturn this.r(this.es[0].value(), this.es[1].value());\n\t}\n\n}\n\n\n// -----------------------------------------------------------------------------\n\n\nclass Constraint3 extends Constraint {\n\n\tconstructor(r: (v0: number, v1: number, v2: number) => number, x1: Variable, x2: Variable, x3: Variable) {\n\t\tsuper(r);\n\t\tthis.es = [x1, x2, x3];\n\t}\n\n\temptySize(): number {\n\t\tlet n: number = 0;\n\t\tif (this.es[0].isEmpty()) ++n;\n\t\tif (this.es[1].isEmpty()) ++n;\n\t\tif (this.es[2].isEmpty()) ++n;\n\t\treturn n;\n\t}\n\n\tisDefined(): boolean {\n\t\treturn !this.es[0].isEmpty() && !this.es[1].isEmpty() && !this.es[2].isEmpty();\n\t}\n\n\tstatus(): -1 | 0 | 1 {\n\t\tif (this.es[0].isEmpty() || this.es[1].isEmpty() || this.es[2].isEmpty()) {\n\t\t\treturn -1;  // UNDEFINED\n\t\t}\n\t\treturn 1 === this.r(this.es[0].value(), this.es[1].value(), this.es[2].value()) ? 1 : 0;\n\t}\n\n\tdegree(): number {\n\t\tif (this.es[0].isEmpty() || this.es[1].isEmpty() || this.es[2].isEmpty()) {\n\t\t\treturn -1;  // UNDEFINED\n\t\t}\n\t\treturn this.r(this.es[0].value(), this.es[1].value(), this.es[2].value());\n\t}\n\n}\n\n\n// -----------------------------------------------------------------------------\n\n\nclass ConstraintN extends Constraint {\n\n\t#vs: number[];  // For reuse.\n\n\tconstructor(r: (...vs: number[]) => number, ...xs: Variable[]) {\n\t\tsuper(r);\n\t\tthis.es = [...xs];\n\t\tthis.#vs = new Array(this.es.length);\n\t}\n\n\temptySize(): number {\n\t\tlet n: number = 0;\n\t\tfor (const x of this.es) {\n\t\t\tn += x.isEmpty() ? 1 : 0;\n\t\t}\n\t\treturn n;\n\t}\n\n\tisDefined(): boolean {\n\t\tfor (const x of this.es) {\n\t\t\tif (x.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatus(): -1 | 0 | 1 {\n\t\tfor (let i: number = 0; i < this.es.length; ++i) {\n\t\t\tconst x: Variable = this.es[i];\n\t\t\tif (x.isEmpty()) {\n\t\t\t\treturn -1;  // UNDEFINED\n\t\t\t}\n\t\t\tthis.#vs[i] = x.value();\n\t\t}\n\t\treturn 1 === this.r(...this.#vs) ? 1 : 0;\n\t}\n\n\tdegree(): number {\n\t\tfor (let i: number = 0; i < this.es.length; ++i) {\n\t\t\tconst x: Variable = this.es[i];\n\t\t\tif (x.isEmpty()) {\n\t\t\t\treturn -1;  // UNDEFINED\n\t\t\t}\n\t\t\tthis.#vs[i] = x.value();\n\t\t}\n\t\treturn this.r(...this.#vs);\n\t}\n\n}\n", "/**\n * The class represents a constraint satisfaction problem.\n *\n * @author Takuto Yanagida\n * @version 2025-01-24\n */\n\nimport { Variable } from './variable';\nimport { Domain } from './domain';\nimport { Constraint } from './constraint';\n\nexport class Problem {\n\n\t#fv: (d: Domain) => Variable = (d: Domain): Variable => new Variable(d);\n\t#fc: (r: (...vs: number[]) => number, xs: Variable[]) => Constraint = (r: (...vs: number[]) => number, xs: Variable[]): Constraint => Constraint.create(r, xs);\n\n\t#xs: Variable[]   = [];\n\t#cs: Constraint[] = [];\n\n\n\t// Methods for Modifying Factories -----------------------------------------\n\n\n\t/**\n\t * Sets a variable factory.\n\t */\n\tsetVariableFactory(fn: (d: Domain) => Variable): void {\n\t\tthis.#fv = fn;\n\t}\n\n\t/**\n\t * Sets a variable factory.\n\t */\n\tsetConstraintFactory(fn: (r: (...vs: number[]) => number, xs: Variable[]) => Constraint): void {\n\t\tthis.#fc = fn;\n\t}\n\n\n\t// Generation Methods ------------------------------------------------------\n\n\n\t/**\n\t * Adds a variable to this problem.\n\t * @param Variable v A variable.\n\t */\n\tprotected addVariable(x: Variable): void {\n\t\tx.setIndex(this.#xs.length);\n\t\tthis.#xs.push(x);\n\t}\n\n\t/**\n\t * Generates a domain.\n\t * @param vs Multiple values.\n\t * @return A domain.\n\t */\n\tcreateDomain(vs: number[]): Domain;\n\n\t/**\n\t * Generates a domain.\n\t * @param min Minimum value.\n\t * @param max Maximum value.\n\t * @return A domain.\n\t */\n\tcreateDomain(min: number, max: number): Domain;\n\n\tcreateDomain(vs_min: number[] | number, max: number | null = null): Domain {\n\t\tif (Array.isArray(vs_min)) {\n\t\t\treturn Domain.create(vs_min);\n\t\t} else if (null !== max) {\n\t\t\treturn Domain.create(vs_min, max);\n\t\t}\n\t\tthrow new RangeError();\n\t}\n\n\t/**\n\t * Generates a variable.\n\t * @param variable A Variable.\n\t * @return A variable.\n\t */\n\tcreateVariable(variable: Variable): Variable;\n\n\t/**\n\t * Generates a variable.\n\t * @param domain A domain.\n\t * @param value A value.\n\t * @param name Display name.\n\t * @return A variable.\n\t */\n\tcreateVariable(domain: Domain, value: number | null, name?: string): Variable;\n\n\tcreateVariable(x_d: Variable | Domain, value: number | null = null, name?: string): Variable {\n\t\tif (x_d instanceof Variable) {\n\t\t\tconst x: Variable = this.#fv((x_d as Variable).domain());\n\t\t\tthis.addVariable(x);\n\t\t\tx.setName(x.name());\n\t\t\tx.assign(x.value());\n\t\t\treturn x;\n\t\t} else if (x_d instanceof Domain) {\n\t\t\tif (value !== null && !x_d.contains(value)) {\n\t\t\t\tthrow new Error();\n\t\t\t}\n\t\t\tconst x: Variable = this.#fv(x_d);\n\t\t\tthis.addVariable(x);\n\t\t\tif (value !== null) {\n\t\t\t\tx.assign(value);\n\t\t\t}\n\t\t\tif (name) {\n\t\t\t\tx.setName(name);\n\t\t\t}\n\t\t\treturn x;\n\t\t}\n\t\tthrow new RangeError();\n\t}\n\n\t/**\n\t * Generates a constraint.\n\t * @param relation A relation.\n\t * @param xs       Variables.\n\t * @param name     Display name.\n\t * @return A constraint.\n\t */\n\tcreateConstraint(relation: (...vs: number[]) => number, xs: Variable[], name?: string): Constraint {\n\t\tconst c: Constraint = this.#fc(relation, xs);\n\t\tc.setIndex(this.#cs.length);\n\t\tthis.#cs.push(c);\n\t\tfor (const x of xs) {\n\t\t\tx.connect(c);\n\t\t}\n\t\tif (name) {\n\t\t\tc.setName(name);\n\t\t}\n\t\treturn c;\n\t}\n\n\n\t//  Modification Methods ---------------------------------------------------\n\n\n\t/**\n\t * Remove the constraint.\n\t * @param c Constraints to be removed.\n\t */\n\tremoveConstraint(c: Constraint): void {\n\t\tconst index: number = this.#cs.indexOf(c);\n\t\tthis.#cs.splice(index, 1);\n\t\tfor (let i: number = index; i < this.#cs.length; ++i) {\n\t\t\tthis.#cs[i].setIndex(i);\n\t\t}\n\t\tfor (const x of c) {\n\t\t\tx.disconnect(c);\n\t\t}\n\t}\n\n\t/**\n\t * Changes the status of all variables to unassigned.\n\t */\n\tclearAllVariables(): void {\n\t\tfor (const x of this.#xs) {\n\t\t\tx.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the order of variables.\n\t * The index of each variable is reassigned.\n\t */\n\treverseVariables(): void {\n\t\tthis.#xs.reverse();\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\n\t\t\tthis.#xs[i].setIndex(i);\n\t\t}\n\t}\n\n\t/**\n\t * Sorts variables using a specified comparator.\n\t * The index of each variable is reassigned.\n\t * @param comparator A comparator.\n\t */\n\tsortVariables(comparator: (a: Variable, b: Variable) => number): void {\n\t\tthis.#xs.sort(comparator);\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\n\t\t\tthis.#xs[i].setIndex(i);\n\t\t}\n\t}\n\n\n\t// Methods for Variables ---------------------------------------------------\n\n\n\t/**\n\t * Returns the list of variables.\n\t * The returned list is not allowed to be modified.\n\t * @return The variable list.\n\t */\n\tvariables(): Variable[] {\n\t\treturn this.#xs;\n\t}\n\n\t/**\n\t * Gets the number of variables in the problem.\n\t * @return Number of variables\n\t */\n\tvariableSize(): number {\n\t\treturn this.#xs.length;\n\t}\n\n\t/**\n\t * Gets a variable by index.\n\t * @param index Index (0 <= index < variableSize()).\n\t * @return A variable\n\t */\n\tvariableAt(index: number): Variable {\n\t\treturn this.#xs[index];\n\t}\n\n\t/**\n\t * Gets a variable by name.\n\t * @param name Name.\n\t * @return A variable.\n\t */\n\tvariableOf(name: string): Variable | null {\n\t\tfor (const x of this.#xs) {\n\t\t\tif (x.name() === name) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns whether the variable is contained or not.\n\t * @param x A variable.\n\t * @return True if contained.\n\t */\n\thasVariable(x: Variable): boolean {\n\t\treturn this.#xs.includes(x);\n\t}\n\n\n\t// Methods for Constraints -------------------------------------------------\n\n\n\t/**\n\t * Returns the list of constraint.\n\t * The returned list is not allowed to be modified.\n\t * @return The constraint list.\n\t */\n\tconstraints(): Constraint[] {\n\t\treturn this.#cs;\n\t}\n\n\t/**\n\t * Gets the number of constraints in the problem.\n\t * @return Number of constraints\n\t */\n\tconstraintSize(): number {\n\t\treturn this.#cs.length;\n\t}\n\n\t/**\n\t * Gets a constraint by index.\n\t * @param index Index (0 <= index < constraintSize()).\n\t * @return A constraint.\n\t */\n\tconstraintAt(index: number): Constraint {\n\t\treturn this.#cs[index];\n\t}\n\n\t/**\n\t * Gets a constraint by name.\n\t * @param name Name.\n\t * @return A constraint.\n\t */\n\tconstraintOf(name: string): Constraint | null {\n\t\tfor (const c of this.#cs) {\n\t\t\tif (c.name() === name) {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns whether the constraint is contained or not.\n\t * @param c A constraint\n\t * @return True if contained.\n\t */\n\thasConstraint(c: Constraint): boolean {\n\t\treturn this.#cs.includes(c);\n\t}\n\n\t/**\n\t * Gets the constraints that exist between the specified variables.\n\t * Returns an empty array if no constraints exist.\n\t * If there are multiple constraints between two variables (including the case of n-ary constraints (2 < n)), they will be included in the return array.\n\t * @param v1 Variable 1\n\t * @param v2 Variable 2\n\t * @return Constraints.\n\t */\n\tconstraintsBetween(v1: Variable, v2: Variable): Constraint[] {\n\t\tconst cs: Constraint[] = [];\n\t\tfor (const c of v1) {\n\t\t\tif (c.has(v2)) {\n\t\t\t\tcs.push(c);\n\t\t\t}\n\t\t}\n\t\treturn cs;\n\t}\n\n\n\t// State acquisition methods -----------------------------------------------\n\n\n\t/**\n\t * Gets the constraint density (number of constraints/number of variables).\n\t * @return Constraint density.\n\t */\n\tconstraintDensity(): number {\n\t\treturn this.#cs.length / this.#xs.length;\n\t}\n\n\t/**\n\t * Returns the number of variables in the problem that have not been assigned a value.\n\t * @return Number of variables with no value assigned.\n\t */\n\temptySize(): number {\n\t\tlet n: number = 0;\n\n\t\tfor (const x of this.#xs) {\n\t\t\tn += x.isEmpty() ? 1 : 0;\n\t\t}\n\t\treturn n;\n\t}\n\n\t/**\n\t * Returns whether the constraint satisfaction problem has any variables with empty domain.\n\t * @return True if it exists.\n\t */\n\thasEmptyDomain(): boolean {\n\t\tfor (const x of this.#xs) {\n\t\t\tif (x.domain().size() === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the worst satisfaction degree for the constraints contained in the fuzzy constraint satisfaction problem.\n\t * If the degree cannot be determined because the variable has not yet been assigned a value or for some other reason, -1 is returned.\n\t * @return Worst satisfaction degree.\n\t */\n\tdegree(): number {\n\t\tlet cur: number = 1;\n\t\tfor (const c of this.#cs) {\n\t\t\tconst ev: number = c.degree();\n\t\t\tif (ev < 0) {  // ev === UNDEFINED\n\t\t\t\treturn ev;\n\t\t\t}\n\t\t\tif (ev < cur) {\n\t\t\t\tcur = ev;\n\t\t\t}\n\t\t}\n\t\treturn cur;\n\t}\n\n\t/**\n\t * Finds the set of worst satisfiable constraints in a fuzzy constraint satisfaction problem.\n\t * @return Array of constraints and worst satisfaction degree.\n\t */\n\tconstraintsWithDegree(): [Constraint[], number] {\n\t\tconst cs: Constraint[] = [];\n\t\tlet cur: number = 1;\n\t\tfor (const c of this.#cs) {\n\t\t\tconst ev: number = c.degree();\n\t\t\tif (ev < cur) {\n\t\t\t\tcur = ev;\n\t\t\t\tcs.length = 0;\n\t\t\t\tcs.push(c);\n\t\t\t} else if (ev - cur < Number.MIN_VALUE * 10) {\n\t\t\t\tcs.push(c);\n\t\t\t}\n\t\t}\n\t\treturn [cs, cur];\n\t}\n\n\t/**\n\t * Gets the average of satisfaction degrees of the fuzzy constraints.\n\t * @return Average of satisfaction degrees.\n\t */\n\taverageDegree(): number {\n\t\tlet s: number = 0;\n\t\tfor (const c of this.#cs) {\n\t\t\ts += c.degree();\n\t\t}\n\t\treturn s / this.#cs.length;\n\t}\n\n\t/**\n\t * Returns the rate of constraints that are satisfied out of all constraints.\n\t * @return Rate of satisfied constraints.\n\t */\n\tratio(): number {\n\t\treturn this.satisfiedConstraintSize() / this.#cs.length;\n\t}\n\n\t/**\n\t * Returns the number of satisfied constraints.\n\t * Undefined constraints are ignored.\n\t * @return Number of satisfied constraints.\n\t */\n\tsatisfiedConstraintSize(): number {\n\t\tlet n: number = 0;\n\t\tfor (const c of this.#cs) {\n\t\t\tn += (c.status() === 1) ? 1 : 0;\n\t\t}\n\t\treturn n;\n\t}\n\n\t/**\n\t * Returns the number of violating constraints.\n\t * Undefined constraints are ignored.\n\t * @return Number of violating constraints.\n\t */\n\tviolatingConstraintSize(): number {\n\t\treturn this.#cs.length - this.satisfiedConstraintSize();\n\t}\n\n\t/**\n\t * Returns a list of satisfied constraints.\n\t * Undefined constraints are ignored.\n\t * @return Array of constraints.\n\t */\n\tsatisfiedConstraints(): Constraint[] {\n\t\tconst cs: Constraint[] = [];\n\t\tfor (const c of this.#cs) {\n\t\t\tif (c.status() === 1) {\n\t\t\t\tcs.push(c);\n\t\t\t}\n\t\t}\n\t\treturn cs;\n\t}\n\n\t/**\n\t * Returns a list of violating constraints.\n\t * Undefined constraints are ignored.\n\t * @return Array of constraints.\n\t */\n\tviolatingConstraints(): Constraint[] {\n\t\tconst cs: Constraint[] = [];\n\t\tfor (const c of this.#cs) {\n\t\t\tif (c.status() === 0) {\n\t\t\t\tcs.push(c);\n\t\t\t}\n\t\t}\n\t\treturn cs;\n\t}\n\n}\n", "/**\n * The class for monitoring solvers.\n *\n * @author Takuto Yanagida\n * @version 2025-01-16\n */\n\nimport { AssignmentList } from './misc/assignment-list';\n\nexport class Monitor {\n\n\t/**\n\t * Whether the debugging mode is on.\n\t */\n\t#debugMode: boolean = true;\n\n\t/**\n\t * Output function for debugging.\n\t */\n\t#debugOutput: (e: any) => void = (e: any): void => console.log(e);\n\n\t/**\n\t * Listener of the solver.\n\t */\n\t#listener: ((as: AssignmentList, wd: number) => boolean) = () => false;\n\n\t/**\n\t *  Limit number of iterations.\n\t */\n\t#iterLimit: number = Number.MAX_SAFE_INTEGER;\n\n\t/**\n\t * Time limit.\n\t */\n\t#timeLimit: number | null = null;\n\n\t/**\n\t * Target 'ratio' or 'degree'.\n\t */\n\t#target: number | null = 0.8;\n\n\t/**\n\t * Number of times the evaluation value is the same before stopping the solver.\n\t */\n\t#sameEvLimit: number | null = null;\n\n\t/**\n\t * End time.\n\t */\n\t#endTime: number = 0;\n\n\t/**\n\t * Number of iterations.\n\t */\n\t#iterCount: number = 0;\n\n\t/**\n\t * Last evaluation value.\n\t */\n\t#lastEv: number = -1;\n\n\t/**\n\t * Number of times the evaluation value is the same.\n\t */\n\t#sameEvCount: number = 0;\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * Initializes the monitor.\n\t */\n\tinitialize(): void {\n\t\tthis.#endTime = (null === this.#timeLimit) ? (\n\t\t\tNumber.MAX_VALUE\n\t\t) : (\n\t\t\tDate.now() + this.#timeLimit\n\t\t);\n\t\tthis.#iterCount = 0;\n\t}\n\n\t/**\n\t * Checks the current status of the solver.\n\t * @param evaluation Evaluation value.\n\t * @returns True if the solver should stop, false if the solver should stop as a failure, and null if the solver should continue.\n\t */\n\tcheck(evaluation: number | null = null): boolean | null {\n\t\tif (null !== evaluation && null !== this.#target && this.#target <= evaluation) {\n\t\t\tthis.outputDebugString('Stop: Current evaluation value is above the target');\n\t\t\treturn true;\n\t\t}\n\t\tif (this.#iterLimit < this.#iterCount++) {\n\t\t\tthis.outputDebugString('Stop: Number of iterations has reached the limit');\n\t\t\treturn false;\n\t\t}\n\t\tif (this.#endTime < Date.now()) {\n\t\t\tthis.outputDebugString('Stop: Time limit has been reached');\n\t\t\treturn false;\n\t\t}\n\t\tif (null !== evaluation && null !== this.#sameEvLimit) {\n\t\t\tif (evaluation !== -1 && this.#lastEv === evaluation) {\n\t\t\t\tif (this.#sameEvLimit < this.#sameEvCount++) {\n\t\t\t\t\tthis.outputDebugString('Stop: Evaluation value has not changed for a certain number of times');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.#lastEv      = evaluation;\n\t\t\t\tthis.#sameEvCount = 0;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Called by the solver when a solution is found.\n\t * @param solution Solution.\n\t * @param evaluation Evaluation value.\n\t * @returns Whether to stop the solver.\n\t */\n\tsolutionFound(solution: AssignmentList, evaluation: number): boolean {\n\t\treturn this.#listener(solution, evaluation);\n\t}\n\n\t/**\n\t * Called by the solver to output debug strings.\n\t * @param str String to output.\n\t */\n\toutputDebugString(str: any): void {\n\t\tif (this.#debugMode) this.#debugOutput(str);\n\t}\n\n\t/**\n\t * Called by the solver to check if the debugging mode is on.\n\t * @returns Whether the debugging mode is on.\n\t */\n\tisDebugMode(): boolean {\n\t\treturn this.#debugMode;\n\t}\n\n\t/**\n\t * Called by the solver to check if the target is set.\n\t * @returns Whether the target is set.\n\t */\n\tisTargetAssigned(): boolean {\n\t\treturn null !== this.#target;\n\t}\n\n\t/**\n\t * Called by the solver to check if the target is set.\n\t * @returns Whether the target is set.\n\t */\n\tgetTarget(): number | null {\n\t\treturn this.#target;\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * Sets and limits the maximum number of iterations for the solver's behavior.\n\t * After the specified number of iterations, the solver stops as a failure. The specific behavior depends on the solver.\n\t * @param count Maximum value; null means not set.\n\t */\n\tsetIterationLimit(count: number | null = null): void {\n\t\tthis.#iterLimit = (null === count) ? Number.MAX_SAFE_INTEGER : count;\n\t}\n\n\t/**\n\t * Sets a time limit on the solver's behavior.\n\t * If the specified time is exceeded, the solver stops as a failure. The specific behavior depends on the solver.\n\t * @param msec Time limit. null means not set.\n\t */\n\tsetTimeLimit(msec: number | null = null): void {\n\t\tthis.#timeLimit = msec;\n\t}\n\n\t/**\n\t * The goal to be achieved, which is the condition for stopping the solver, is set as the constraint satisfaction degree (fuzzy) or the percentage of constraints satisfied (crisp).\n\t * The solver stops as success if the specified percentage is reached or exceeded. The specific behavior depends on the solver.\n\t * @param rate Degree or rate. null indicates not set.\n\t */\n\tsetTarget(rate: number | null = null): void {\n\t\tthis.#target = rate;\n\t}\n\n\t/**\n\t * Sets the number of times the evaluation value is the same before stopping the solver.\n\t * @param count Count; null means not set.\n\t */\n\tsetSameEvaluationLimit(count: number | null = null): void {\n\t\tthis.#sameEvLimit = count;\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * Sets the listener of the solver.\n\t * @param l Listener function.\n\t */\n\tsetListener(l: (solution: AssignmentList, worstDegree: number) => boolean): void {\n\t\tthis.#listener = l;\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * Sets whether to output debug strings.\n\t * @param boolean flag Do output if true.\n\t */\n\tsetDebugMode(flag: boolean): void {\n\t\tthis.#debugMode = flag;\n\t}\n\n\t/**\n\t * Sets a function that used for outputting debug strings.\n\t * @param function fn Function called when debug output.\n\t */\n\tsetDebugOutput(fn: (e: any) => void): void {\n\t\tthis.#debugOutput = fn;\n\t}\n\n}\n", "/**\n * The class for solvers for finding solutions to CSPs.\n *\n * @author Takuto Yanagida\n * @version 2025-01-03\n */\n\nimport { Problem } from '../problem/problem';\nimport { Monitor } from './monitor';\n\nexport class Solver {\n\n\t/**\n\t * The crisp/fuzzy CSP solved by the solver.\n\t */\n\tprotected pro!: Problem;\n\n\t/**\n\t * Monitor for the solver.\n\t */\n\tprotected monitor!: Monitor;\n\n\t/**\n\t * Generates a solver.\n\t */\n\tconstructor() {\n\t}\n\n\t/**\n\t * Returns the name of the solver.\n\t * @return The name.\n\t */\n\tname(): string {\n\t\treturn '';\n\t}\n\n\t/**\n\t * Computes the solution to a CSP.\n\t * The specific meaning of the return value depends on the implementation of the algorithm.\n\t * @param p A CSP.\n\t * @param m Monitor.\n\t * @return True if the algorithm succeeds\n\t */\n\tsolve(p: Problem, m: Monitor = new Monitor()): boolean {\n\t\tthis.pro     = p;\n\t\tthis.monitor = m;\n\n\t\tthis.preprocess();\n\t\tconst ret: boolean = this.exec();\n\t\tthis.postprocess();\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Placeholder for implementing preprocess.\n\t */\n\tprotected preprocess(): void {\n\t}\n\n\t/**\n\t * Placeholder for implementing an algorithm.\n\t * The solve method calls this method and returns the return value of this method.\n\t * @return True if the algorithm succeeds,\n\t */\n\tprotected exec(): boolean {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Placeholder for implementing postprocess.\n\t */\n\tprotected postprocess(): void {\n\t}\n\n}\n", "/**\n * The class represents a pair of variables and the values to be assigned to them.\n *\n * @author Takuto Yanagida\n * @version 2025-01-18\n */\n\nimport { Variable } from '../../problem/variable';\n\nexport class Assignment {\n\n\t#x: Variable;\n\t#v: number;\n\n\t/**\n\t * Create an assignment.\n\t * @param a_x An assignment or a variable.\n\t */\n\tconstructor(a_x: Assignment | Variable);\n\n\t/**\n\t * Create an assignment.\n\t * @param x Variable.\n\t * @param value A value to be assigned.\n\t */\n\tconstructor(x: Variable, value: number | null);\n\n\tconstructor(a_x: Assignment | Variable, value: number | null = null) {\n\t\tif (a_x instanceof Assignment) {\n\t\t\tthis.#x = (a_x as Assignment).variable();\n\t\t\tthis.#v = (a_x as Assignment).value();\n\t\t} else if (a_x instanceof Variable) {\n\t\t\tthis.#x = (a_x as Variable);\n\t\t\tthis.#v = value ?? (a_x as Variable).value();\n\t\t} else {\n\t\t\tthrow new RangeError();\n\t\t}\n\t}\n\n\t/**\n\t * Assigns a value to a stored variable.\n\t */\n\tapply(): void {\n\t\tthis.#x.assign(this.#v);\n\t}\n\n\t/**\n\t * Returns a string representation.\n\t * @return A string representation.\n\t */\n\ttoString(): string {\n\t\treturn `v${this.#x.index()} <- ${this.#v}`;\n\t}\n\n\t/**\n\t * Gets the value.\n\t * @return Value.\n\t */\n\tvalue(): number {\n\t\treturn this.#v;\n\t}\n\n\t/**\n\t * Gets the variable.\n\t * @return Variable.\n\t */\n\tvariable(): Variable {\n\t\treturn this.#x;\n\t}\n\n}\n", "/**\n * Utility functions for random numbers.\n * @author Takuto Yanagida\n * @version 2025-01-24\n */\n\nlet generator: () => number = Math.random;\n\n/**\n * Set a seed number\n * @param {number} seed Seed number\n */\nexport function setSeed(seed: number = Math.random() * 997): void {\n\tgenerator = createGenerator(seed);\n}\n\n/**\n * Return a random number from min to max\n * @return {number} A random number\n */\nexport function random(): number {\n\treturn generator();\n}\n\n/**\n * Returns a random number from 0 to n_min\n * @param {number} n An integer\n * @return {number} A random integer\n */\nexport function rand(n: number): number {\n\tconsole.log(generator === Math.random)\n\treturn Math.floor(generator() * n);\n}\n\n/**\n * Create a function that returns a random number (Xorshift32) (used only in the library)\n * @private\n * @param {number} seed Seed number\n * @return {function():number} Function that returns a random number\n */\nfunction createGenerator(seed: number): () => number {\n\tlet y: number = seed;\n\treturn (): number => {\n\t\ty = y ^ (y << 13);\n\t\ty = y ^ (y >> 17);\n\t\ty = y ^ (y << 15);\n\t\treturn (y + 2147483648) / 4294967295;\n\t};\n}\n", "/**\n * The class represents multiple variables and their assignments.\n *\n * @author Takuto Yanagida\n * @version 2025-01-24\n */\n\nimport { Assignment } from './assignment';\nimport { Variable } from '../../problem/variable';\nimport { Problem } from '../../problem/problem';\nimport { rand } from './random';\n\nexport class AssignmentList {\n\n\t/**\n\t * Creates an assignment list from variables.\n\t * @param xs Variables.\n\t * @return Assignment list.\n\t */\n\tstatic fromVariables(xs: Iterable<Variable>): AssignmentList {\n\t\tconst al = new AssignmentList();\n\t\tal.setVariables(xs);\n\t\treturn al;\n\t}\n\n\t#as: Assignment[] = [];\n\n\tconstructor() {\n\t}\n\n\t/**\n\t * Sets a problem.\n\t * @param p Problem.\n\t */\n\tsetProblem(p: Problem): void {\n\t\tthis.#as.length = 0;\n\t\tfor (const x of p.variables()) {\n\t\t\tthis.#as.push(new Assignment(x));\n\t\t}\n\t}\n\n\t/**\n\t * Sets assignments.\n\t * @param al Assignments.\n\t */\n\tsetAssignmentList(al: AssignmentList): void {\n\t\tthis.#as.length = 0;\n\t\tfor (const a of al) {\n\t\t\tthis.#as.push(new Assignment(a));\n\t\t}\n\t}\n\n\t/**\n\t * Sets variables.\n\t * @param xs Variables.\n\t */\n\tsetVariables(xs: Iterable<Variable>): void {\n\t\tthis.#as.length = 0;\n\t\tfor (const x of xs) {\n\t\t\tthis.#as.push(new Assignment(x));\n\t\t}\n\t}\n\n\t/**\n\t * Adds a variable and its value.\n\t * @param x Variable.\n\t * @param value Value.\n\t */\n\taddVariable(x: Variable, value: number | null = null): void {\n\t\tthis.#as.push(new Assignment(x, value));\n\t}\n\n\t/**\n\t * Applies all assignments.\n\t */\n\tapply(): void {\n\t\tfor (const a of this.#as) a.apply();\n\t}\n\n\t/**\n\t * Remove all assignments.\n\t */\n\tclear(): void {\n\t\tthis.#as.length = 0;\n\t}\n\n\t/**\n\t * Checks whether the list is empty or not.\n\t * @return True if empty.\n\t */\n\tisEmpty(): boolean {\n\t\treturn 0 === this.#as.length;\n\t}\n\n\t/**\n\t * Gets the number of assignments.\n\t * @return Number of assignments.\n\t */\n\tsize(): number {\n\t\treturn this.#as.length;\n\t}\n\n\t/**\n\t * Gets the number of different assignments.\n\t * @return Number of different assignments.\n\t */\n\tdifferenceSize(): number {\n\t\tlet diff: number = 0;\n\n\t\tfor (const a of this.#as) {\n\t\t\tif (a.variable().value() !== a.value()) {\n\t\t\t\t++diff;\n\t\t\t}\n\t\t}\n\t\treturn diff;\n\t}\n\n\t/**\n\t * Gets the assignments by specifying their indices.\n\t * @param index Index.\n\t * @return An assignment.\n\t */\n\tat(index: number): Assignment {\n\t\treturn this.#as[index];\n\t}\n\n\t/**\n\t * Gets the iterator of the assignments.\n\t */\n\t[Symbol.iterator](): Iterator<Assignment> {\n\t\treturn this.#as[Symbol.iterator]();\n\t}\n\n\t/**\n\t * Gets an arbitrary assignment.\n\t *\n\t * @return An assignment.\n\t */\n\trandom(): Assignment {\n\t\treturn this.#as[rand(this.#as.length)];\n\t}\n\n}\n", "/**\n * Utilities for calculating consistency degree.\n *\n * @author Takuto Yanagida\n * @version 2025-01-23\n */\n\nimport { Problem } from '../../problem/problem';\nimport { Variable } from '../../problem/variable';\nimport { Domain } from '../../problem/domain';\nimport { Constraint } from '../../problem/constraint';\n\n/**\n * Calculates the highest and lowest consistency degrees.\n * @param p A problem.\n * @return The pair of the highest and lowest consistency degrees.\n */\nexport function consistencyDegreeOfProblem(p: Problem): [number, number] {\n\tlet L: number = 1;\n\tlet H: number = 0;\n\n\tfor (const c of p.constraints()) {\n\t\tconst l: number = lowestConsistencyDegree(c);\n\t\tconst h: number = highestConsistencyDegree(c);\n\t\tif (l < L) L = l;\n\t\tif (H < h) H = h;\n\t}\n\treturn [L, H];\n}\n\n/**\n * Calculates the highest consistency degree.\n * That is, it seeks the highest satisfaction degree of the possible combinations of variable assignments for a given constraint.\n * When all associated variables have been assigned values, it returns the same value as degree().\n * @param c A constraint.\n * @return The highest consistency degree.\n */\nexport function highestConsistencyDegree(c: Constraint): number {\n\tconst s: number = c.size();\n\tif (1 === s) return highestConsistencyDegree1(c);\n\tif (2 === s) return highestConsistencyDegree2(c);\n\tif (3 === s) return highestConsistencyDegree3(c);\n\treturn highestConsistencyDegreeN(c);\n}\n\n/**\n * Calculates the lowest consistency degree.\n * That is, it seeks the lowest satisfaction degree of the possible combinations of variable assignments for a given constraint.\n * When all associated variables have been assigned values, it returns the same value as degree().\n * @param c A constraint.\n * @return The lowest consistency degree.\n */\nexport function lowestConsistencyDegree(c: Constraint): number {\n\tconst s: number = c.size();\n\tif (1 === s) return lowestConsistencyDegree1(c);\n\tif (2 === s) return lowestConsistencyDegree2(c);\n\tif (3 === s) return lowestConsistencyDegree3(c);\n\treturn lowestConsistencyDegreeN(c);\n}\n\n/**\n * Calculates the highest consistency degree of a unary constraint.\n * @param c A constraint.\n * @return The highest consistency degree.\n */\nfunction highestConsistencyDegree1(c: Constraint): number {\n\tconst ev: number = c.degree();\n\tif (0 <= ev) {  // ev !== UNDEFINED\n\t\treturn ev;\n\t}\n\tconst x: Variable = (c.at(0) as Variable);\n\tlet cd: number = 0;\n\tfor (const v of x.domain()) {\n\t\tconst ev: number = c.relation()(v);\n\t\tif (cd < ev) {\n\t\t\tcd = ev;\n\t\t}\n\t\tif (1 === cd) return 1;\n\t}\n\treturn cd;\n}\n\n/**\n * Calculates the lowest consistency degree of a unary constraint.\n * @param c A constraint.\n * @return The lowest consistency degree.\n */\nfunction lowestConsistencyDegree1(c: Constraint): number {\n\tconst ev: number = c.degree();\n\tif (0 <= ev) {  // ev !== UNDEFINED\n\t\treturn ev;\n\t}\n\tconst x: Variable = (c.at(0) as Variable);\n\tlet cd: number = 1;\n\tfor (const v of x.domain()) {\n\t\tconst ev: number = c.relation()(v);\n\t\tif (ev < cd) {\n\t\t\tcd = ev;\n\t\t}\n\t\tif (0 === cd) return 0;\n\t}\n\treturn cd;\n}\n\n/**\n * Calculates the highest consistency degree of a binary constraint.\n * @param c A constraint.\n * @return The highest consistency degree.\n */\nfunction highestConsistencyDegree2(c: Constraint): number {\n\tconst ev: number = c.degree();\n\tif (0 <= ev) {  // ev !== UNDEFINED\n\t\treturn ev;\n\t}\n\tconst x0: Variable = c.at(0) as Variable;\n\tconst x1: Variable = c.at(1) as Variable;\n\n\tconst d0: Iterable<number> = x0.isEmpty() ? x0.domain() : [x0.value()];\n\tconst d1: Iterable<number> = x1.isEmpty() ? x1.domain() : [x1.value()];\n\n\tlet cd: number = 0;\n\tfor (const v0 of d0) {\n\t\tfor (const v1 of d1) {\n\t\t\tconst ev: number = c.relation()(v0, v1);\n\t\t\tif (cd < ev) {\n\t\t\t\tcd = ev;\n\t\t\t}\n\t\t\tif (1 === cd) return 1\n\t\t}\n\t}\n\treturn cd;\n}\n\n/**\n * Calculates the lowest consistency degree of a binary constraint.\n * @param c A constraint.\n * @return The lowest consistency degree.\n */\nfunction lowestConsistencyDegree2(c: Constraint): number {\n\tconst ev: number = c.degree();\n\tif (0 <= ev) {  // ev !== UNDEFINED\n\t\treturn ev;\n\t}\n\tconst x0: Variable = c.at(0) as Variable;\n\tconst x1: Variable = c.at(1) as Variable;\n\n\tconst d0: Iterable<number> = x0.isEmpty() ? x0.domain() : [x0.value()];\n\tconst d1: Iterable<number> = x1.isEmpty() ? x1.domain() : [x1.value()];\n\n\tlet cd: number = 1;\n\tfor (const v0 of d0) {\n\t\tfor (const v1 of d1) {\n\t\t\tconst ev: number = c.relation()(v0, v1);\n\t\t\tif (ev < cd) {\n\t\t\t\tcd = ev;\n\t\t\t}\n\t\t\tif (0 === cd) return 0;\n\t\t}\n\t}\n\treturn cd;\n}\n\n/**\n * Calculates the highest consistency degree of a trinary constraint.\n * @param c A constraint.\n * @return The highest consistency degree.\n */\nfunction highestConsistencyDegree3(c: Constraint): number {\n\tconst ev: number = c.degree();\n\tif (0 <= ev) {  // ev !== UNDEFINED\n\t\treturn ev;\n\t}\n\tconst x0: Variable = c.at(0) as Variable;\n\tconst x1: Variable = c.at(1) as Variable;\n\tconst x2: Variable = c.at(2) as Variable;\n\n\tconst d0: Iterable<number> = x0.isEmpty() ? x0.domain() : [x0.value()];\n\tconst d1: Iterable<number> = x1.isEmpty() ? x1.domain() : [x1.value()];\n\tconst d2: Iterable<number> = x2.isEmpty() ? x2.domain() : [x2.value()];\n\n\tlet cd: number = 0;\n\tfor (const v0 of d0) {\n\t\tfor (const v1 of d1) {\n\t\t\tfor (const v2 of d2) {\n\t\t\t\tconst ev: number = c.relation()(v0, v1, v2);\n\t\t\t\tif (cd < ev) {\n\t\t\t\t\tcd = ev;\n\t\t\t\t}\n\t\t\t\tif (1 === cd) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cd;\n}\n\n/**\n * Calculates the lowest consistency degree of a trinary constraint.\n * @param c A constraint.\n * @return The lowest consistency degree.\n */\nfunction lowestConsistencyDegree3(c: Constraint): number {\n\tconst ev: number = c.degree();\n\tif (0 <= ev) {  // ev !== UNDEFINED\n\t\treturn ev;\n\t}\n\tconst x0: Variable = c.at(0) as Variable;\n\tconst x1: Variable = c.at(1) as Variable;\n\tconst x2: Variable = c.at(2) as Variable;\n\n\tconst d0: Iterable<number> = x0.isEmpty() ? x0.domain() : [x0.value()];\n\tconst d1: Iterable<number> = x1.isEmpty() ? x1.domain() : [x1.value()];\n\tconst d2: Iterable<number> = x2.isEmpty() ? x2.domain() : [x2.value()];\n\n\tlet cd: number = 1;\n\tfor (const v0 of d0) {\n\t\tfor (const v1 of d1) {\n\t\t\tfor (const v2 of d2) {\n\t\t\t\tconst ev: number = c.relation()(v0, v1, v2);\n\t\t\t\tif (ev < cd) {\n\t\t\t\t\tcd = ev;\n\t\t\t\t}\n\t\t\t\tif (0 === cd) return 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn cd;\n}\n\n/**\n * Calculates the highest consistency degree of a N-ary constraint.\n * @param c A constraint.\n * @return The highest consistency degree.\n */\nfunction highestConsistencyDegreeN(c: Constraint): number {\n\tconst ev: number = c.degree();\n\tif (0 <= ev) {  // ev !== UNDEFINED\n\t\treturn ev;\n\t}\n\tconst emptyIndices = new Array(c.emptySize());\n\tlet j: number = 0;\n\n\tconst vs: number[] = new Array(c.size());\n\tfor (let i: number = 0, I: number = c.size(); i < I; ++i) {\n\t\tconst x: Variable = (c.at(i) as Variable);\n\t\tif (x.isEmpty()) {\n\t\t\temptyIndices[j++] = i;\n\t\t} else {\n\t\t\tvs[i] = x.value();\n\t\t}\n\t}\n\treturn checkHCD(c, vs, emptyIndices, 0, 0);\n}\n\n/**\n * Calculates the lowest consistency degree of a N-ary constraint.\n * @param c A constraint.\n * @return The lowest consistency degree.\n */\nfunction lowestConsistencyDegreeN(c: Constraint): number {\n\tconst ev: number = c.degree();\n\tif (0 <= ev) {  // ev !== UNDEFINED\n\t\treturn ev;\n\t}\n\tconst emptyIndices = new Array(c.emptySize());\n\tlet j: number = 0;\n\n\tconst vs: number[] = new Array(c.size());\n\tfor (let i: number = 0, I: number = c.size(); i < I; ++i) {\n\t\tconst x: Variable = (c.at(i) as Variable);\n\t\tif (x.isEmpty()) {\n\t\t\temptyIndices[j++] = i;\n\t\t} else {\n\t\t\tvs[i] = x.value();\n\t\t}\n\t}\n\treturn checkLCD(c, vs, emptyIndices, 0, 1);\n}\n\nfunction checkHCD(c: Constraint, vs: number[], emptyIndices: number[], currentStep: number, cd: number): number {\n\tconst index: number = emptyIndices[currentStep];\n\tconst d    : Domain = (c.at(index) as Variable).domain();\n\n\tif (currentStep === emptyIndices.length - 1) {\n\t\tfor (const v of d) {\n\t\t\tvs[index] = v;\n\t\t\tconst ev: number = c.relation()(...vs);\n\t\t\tif (cd < ev) {\n\t\t\t\tcd = ev;\n\t\t\t}\n\t\t\tif (1 === cd) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (const v of d) {\n\t\t\tvs[index] = v;\n\t\t\tcd = checkHCD(c, vs, emptyIndices, currentStep + 1, cd);\n\t\t}\n\t}\n\treturn cd;\n}\n\nfunction checkLCD(c: Constraint, vs: number[], emptyIndices: number[], currentStep: number, cd: number): number {\n\tconst index: number = emptyIndices[currentStep];\n\tconst d    : Domain = (c.at(index) as Variable).domain();\n\n\tif (currentStep === emptyIndices.length - 1) {\n\t\tfor (const v of d) {\n\t\t\tvs[index] = v;\n\t\t\tconst ev: number = c.relation()(...vs);\n\t\t\tif (ev < cd) {\n\t\t\t\tcd = ev;\n\t\t\t}\n\t\t\tif (0 === cd) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (const v of d) {\n\t\t\tvs[index] = v;\n\t\t\tcd = checkLCD(c, vs, emptyIndices, currentStep + 1, cd);\n\t\t}\n\t}\n\treturn cd;\n}\n", "/**\n * A class that implements the flexible local changes method.\n * The implementation is optimized by converting recursive calls to loops.\n *\n * @author Takuto Yanagida\n * @version 2025-01-23\n */\n\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { AssignmentList } from '../misc/assignment-list';\nimport { consistencyDegreeOfProblem, lowestConsistencyDegree } from '../misc/consistency';\nimport { Solver } from '../solver';\n\nexport class FlexibleLocalChanges extends Solver {\n\n\t#lt!: number;\n\t#lb!: number;\n\n\t#wsd!      : number;\n\t#globalRet!: number;\n\n\t/**\n\t * Generates a solver.\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\toverride name(): string {\n\t\treturn 'Flexible Local Changes';\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override preprocess(): void {\n\t\t[this.#lb, this.#lt] = consistencyDegreeOfProblem(this.pro);\n\t\tthis.#wsd = this.pro.degree();\n\t\tif (this.pro.emptySize() === 0) {\n\t\t\tthis.pro.clearAllVariables();\n\t\t}\n\t\tthis.#globalRet = -1;\n\n\t\tthis.monitor.initialize();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override exec(): boolean {\n\t\tconst X1 = new Set<Variable>();\n\t\tconst X2 = new Set<Variable>();  // Currently assigned variables.\n\t\tconst X3 = new Set<Variable>();  // Currently unassigned variables.\n\n\t\tfor (const x of this.pro.variables()) {\n\t\t\t(!x.isEmpty() ? X2 : X3).add(x);\n\t\t}\n\n\t\tconst cr               = new Set<Constraint>();\n\t\tconst initCons: number = this.#initTest(X2, cr);\n\t\tlet rc     : number;\n\t\tlet initSol: AssignmentList | null = null;\n\n\t\tif (0 === X3.size) {\n\t\t\trc      = initCons;\n\t\t\tinitSol = AssignmentList.fromVariables(X2);\n\t\t} else {\n\t\t\trc = this.#lb;\n\t\t}\n\t\tconst X3p: Set<Variable> = this.#choose(X2, cr).union(X3);\n\t\tconst X2p: Set<Variable> = X2.difference(X3p);\n\n\t\tlet result: number = this.#flcVariables(X1, X2p, X3p, this.#lt, this.#lt, rc);\n\t\tif (result < rc) {\n\t\t\tif (initSol !== null) {\n\t\t\t\tinitSol.apply();\n\t\t\t}\n\t\t}\n\t\tresult = this.pro.degree();\n\t\treturn this.#wsd < result && 0 < result && (this.#globalRet !== 0 || this.monitor.getTarget() === null);\n\t}\n\n\t#choose(x2: Set<Variable>, cr: Set<Constraint>): Set<Variable> {\n\t\tconst res = new Map<Variable, number>();\n\n\t\tfor (const c of cr) {\n\t\t\tif (!c.isDefined()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (const x of c) {\n\t\t\t\tif (!res.has(x)) {\n\t\t\t\t\tres.set(x, 1);\n\t\t\t\t} else {\n\t\t\t\t\tres.set(x, (res.get(x) ?? 0) + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst xs: Variable[] = [...x2];\n\t\txs.sort((o1: Variable, o2: Variable): -1 | 0 | 1 => {\n\t\t\tlet res1: number = 0;\n\t\t\tlet res2: number = 0;\n\t\t\tif (res.has(o1)) res1 = res.get(o1) ?? 0;\n\t\t\tif (res.has(o2)) res2 = res.get(o2) ?? 0;\n\n\t\t\tif (res1 < res2) return 1;\n\t\t\tif (res2 < res1) return -1;\n\t\t\treturn 0;\n\t\t});\n\n\t\tconst ret = new Set<Variable>();\n\n\t\tfor (const x of xs) {\n\t\t\tlet remain: boolean = false;\n\t\t\tfor (const c of cr) {\n\t\t\t\tif (c.isDefined()) {\n\t\t\t\t\tremain = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!remain) break;\n\t\t\tx.clear();\n\t\t\tret.add(x);\n\t\t}\n\t\treturn ret;\n\t}\n\n\t#flcVariables(X1: Set<Variable>, X2: Set<Variable>, X3: Set<Variable>, consX1: number, consX12: number, rc: number): number {\n\t\tX2 = new Set<Variable>(X2);  // Clone\n\t\tX3 = new Set<Variable>(X3);  // Clone\n\n\t\twhile (true) {\n\t\t\tthis.monitor.outputDebugString(`X1 ${X1.size}, X2' ${X2.size}, X3' ${X3.size}`);\n\n\t\t\tconst ret: boolean | null = this.monitor.check(this.pro.degree());\n\t\t\tif (ret !== null) {\n\t\t\t\tthis.#globalRet = ret ? 1 : 0;\n\t\t\t\treturn consX12;\n\t\t\t}\n\t\t\tif (0 === X3.size) {\n\t\t\t\treturn consX12;\n\t\t\t}\n\t\t\tconst xi                = X3.values().next().value as Variable;\n\t\t\tconst consX12xi: number = this.#flcVariable(X1, X2, xi, consX1, consX12, rc);\n\n\t\t\tif (this.#globalRet !== -1) {\n\t\t\t\treturn consX12;\n\t\t\t}\n\t\t\tif (consX12xi < rc) {\n\t\t\t\treturn this.#lb;\n\t\t\t}\n\t\t\tX2.add(xi);\n\t\t\tX3.delete(xi);\n\t\t\tconsX12 = consX12xi;\n\t\t}\n\t}\n\n\t#flcVariable(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1: number, consX12: number, rc: number): number {\n\t\tlet bestCons: number = this.#lb;\n\t\tif (xi.domain().size() === 0) {\n\t\t\treturn bestCons;\n\t\t}\n\t\tlet bestX2 : AssignmentList = AssignmentList.fromVariables(X2);\n\t\tlet bestDij: number         = xi.domain().at(0);\n\n\t\tconst x2Store: AssignmentList = AssignmentList.fromVariables(X2);\n\n\t\tfor (let j: number = 0; j < xi.domain().size() && bestCons < consX12; ++j) {\n\t\t\tconst dij: number = xi.domain().at(j);\n\t\t\txi.assign(dij);\n\t\t\tconst consX1_xi: number = Math.min(consX1, this.#testX1(X1, xi, bestCons, rc));\n\n\t\t\tif (Math.max(bestCons, rc) < consX1_xi) {\n\t\t\t\tconst crNew              = new Set<Constraint>();\n\t\t\t\tconst consX12_xi: number = Math.min(Math.min(consX1_xi, consX12), this.#testX12(X1, X2, xi, consX1_xi, consX12, crNew));\n\n\t\t\t\tif (bestCons < consX12_xi) {\n\t\t\t\t\tbestCons = consX12_xi;\n\t\t\t\t\tbestDij  = dij;\n\t\t\t\t\tbestX2   = AssignmentList.fromVariables(X2);\n\t\t\t\t}\n\t\t\t\tif (crNew.size) {\n\t\t\t\t\tconst repairCons: number = this.#flcRepair(X1, X2, xi, consX1_xi, consX12, crNew, Math.max(rc, bestCons));\n\t\t\t\t\tif (this.#globalRet !== -1) {\n\t\t\t\t\t\treturn bestCons;\n\t\t\t\t\t}\n\t\t\t\t\tif (bestCons < repairCons) {\n\t\t\t\t\t\tbestCons = repairCons;\n\t\t\t\t\t\tbestDij  = dij;\n\t\t\t\t\t\tbestX2   = AssignmentList.fromVariables(X2);\n\t\t\t\t\t}\n\t\t\t\t\tx2Store.apply();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbestX2.apply();\n\t\txi.assign(bestDij);\n\t\treturn bestCons;\n\t}\n\n\t#flcRepair(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1xi: number, consX12: number, cr: Set<Constraint>, rc: number): number {\n\t\tconst X3p: Set<Variable> = this.#choose(X2, cr);\n\t\tconst X1p: Set<Variable> = cloneAndAdd(X1, xi);\n\t\tconst X2p: Set<Variable> = X2.difference(X3p);\n\t\treturn this.#flcVariables(X1p, X2p, X3p, consX1xi, Math.min(consX12, consX1xi), rc);\n\t}\n\n\t#initTest(X: Set<Variable>, cr: Set<Constraint>): number {\n\t\tconst cs = new Set<Constraint>();\n\n\t\tfor (const x of X) {\n\t\t\tfor (const c of x) {\n\t\t\t\tcs.add(c);  // All variables in X have been assigned.\n\t\t\t}\n\t\t}\n\t\tlet ret: number = 1;\n\t\tfor (const c of cs) {\n\t\t\tconst sd: number = c.degree();\n\t\t\tif (sd < 0) {  // sd === UNDEFINED\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sd < ret) {\n\t\t\t\tret = sd;\n\t\t\t}\n\t\t}\n\t\tfor (const c of this.pro.constraints()) {\n\t\t\tconst cd: number = lowestConsistencyDegree(c);\n\t\t\tif (cd < this.#lt) {\n\t\t\t\tcr.add(c);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t#testX1(X1: Set<Variable>, xi: Variable, bestCons: number, rc: number): number {\n\t\tlet cd: number = 1;\n\t\tconst cs = new Set<Constraint>();\n\n\t\tfor (const x of X1) {\n\t\t\tconst temp: Constraint[] = this.pro.constraintsBetween(x, xi);\n\t\t\tfor (const c of temp) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tfor (const c of cs) {\n\t\t\tconst d: number = c.degree();\n\t\t\tif (d < 0) {  // d === UNDEFINED\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (d < cd) {\n\t\t\t\tcd = d;\n\t\t\t}\n\t\t\t// If it is determined that a better solution than the current solution cannot be obtained\n\t\t\tif (cd <= bestCons || cd <= rc) {\n\t\t\t\treturn cd;\n\t\t\t}\n\t\t}\n\t\treturn cd;\n\t}\n\n\t#testX12(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1xi: number, consX12: number, cr: Set<Constraint>): number {\n\t\tlet csd: number = 1;\n\t\tconst cs = new Set<Constraint>();\n\n\t\tfor (const x of X1) {\n\t\t\tconst temp: Constraint[] = this.pro.constraintsBetween(x, xi);\n\t\t\tfor (const c of temp) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tfor (const x of X2) {\n\t\t\tconst temp: Constraint[] = this.pro.constraintsBetween(x, xi);\n\t\t\tfor (const c of temp) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tfor (const c of cs) {\n\t\t\tconst sd: number = c.degree();\n\t\t\tif (sd < 0) {  // sd === UNDEFINED\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sd < csd) {\n\t\t\t\tcsd = sd;\n\t\t\t}\n\t\t}\n\t\tfor (const c of cs) {\n\t\t\tconst sd: number = c.degree();\n\t\t\tif (sd < 0) {  // sd === UNDEFINED\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sd < consX1xi || sd < consX12) {\n\t\t\t\tcr.add(c);\n\t\t\t}\n\t\t}\n\t\treturn csd;\n\t}\n\n}\n\nfunction cloneAndAdd<T>(s: Set<T>, e: T): Set<T> {\n\treturn new Set<T>(s).add(e);\n}\n", "/**\n * This class holds the branch pruning states for a domain.\n *\n * @author Takuto Yanagida\n * @version 2025-01-22\n */\n\nimport { Variable } from '../../problem/variable';\nimport { Domain } from '../../problem/domain';\n\nexport class DomainPruner {\n\n\tstatic readonly #UNPRUNED: number = Number.MIN_SAFE_INTEGER;\n\n\t#prunedLvs : number[];\n\t#prunedSize: number = 0;\n\n\t/**\n\t * Generates a class that holds branch pruning states for a domain.\n\t * @param size Size of the corresponding domain\n\t */\n\tconstructor(size: number) {\n\t\tthis.#prunedLvs = new Array(size);\n\t\tthis.#prunedLvs.fill(DomainPruner.#UNPRUNED);\n\t}\n\n\t/**\n\t * Returns the size of the erased element.\n\t * @return Size of the erased element.\n\t */\n\tprunedSize(): number {\n\t\treturn this.#prunedSize;\n\t}\n\n\t/**\n\t * Erases the element at the specified index.\n\t * @param index Index.\n\t * @param level Level.\n\t */\n\tprune(index: number, level: number): void {\n\t\tif (this.#prunedLvs[index] === DomainPruner.#UNPRUNED) {\n\t\t\t++this.#prunedSize;\n\t\t} else {\n\t\t\tthrow new Error();\n\t\t}\n\t\tthis.#prunedLvs[index] = level;\n\t}\n\n\t/**\n\t * Returns whether the element is empty or not.\n\t * Returns true if all elements have been erased.\n\t * @return True if empty.\n\t */\n\tisEmpty(): boolean {\n\t\treturn this.#prunedLvs.length === this.#prunedSize;\n\t}\n\n\t/**\n\t * Returns whether or not the element at the specified index has been erased.\n\t * @param index Index.\n\t * @return True if erased.\n\t */\n\tisPruned(index: number): boolean {\n\t\treturn this.#prunedLvs[index] !== DomainPruner.#UNPRUNED;\n\t}\n\n\t/**\n\t * Restores the value that had been erased, by specifying a level.\n\t * @param level Level\n\t */\n\trecover(level: number): void {\n\t\tfor (let i: number = 0; i < this.#prunedLvs.length; ++i) {\n\t\t\tif (this.#prunedLvs[i] === level) {\n\t\t\t\tthis.#prunedLvs[i] = DomainPruner.#UNPRUNED;\n\t\t\t\t--this.#prunedSize;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Restores all erased values.\n\t */\n\trecoverAll(): void {\n\t\tthis.#prunedLvs.fill(DomainPruner.#UNPRUNED);\n\t\tthis.#prunedSize = 0;\n\t}\n\n}\n\n\n// -----------------------------------------------------------------------------\n\n\n/**\n * Returns the index of the variable with the minimum remaining values (MRV).\n * @param xs An array of variables.\n * @param dps An array of domain pruners.\n * @return The index of the variable with the minimum remaining values.\n */\nexport function indexOfVariableWithMRV(xs: Variable[], dps: DomainPruner[]): number {\n\tlet index: number = 0;\n\tlet size : number = Number.MAX_VALUE;\n\n\tfor (let i: number = 0; i < xs.length; ++i) {\n\t\tconst x: Variable = xs[i];\n\t\tif (!x.isEmpty()) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst d: Domain = x.domain();\n\t\tconst s: number = d.size() - dps[x.index()].prunedSize();\n\t\tif (s < size) {\n\t\t\tsize  = s;\n\t\t\tindex = i;\n\t\t}\n\t}\n\treturn index;\n}\n", "/**\n * Classes of utility variables.\n *\n * @author Takuto Yanagida\n * @version 2025-01-24\n */\n\nimport { Variable } from '../problem/variable';\nimport { Domain } from '../problem/domain';\n\n/**\n * Class that represents an observable variable.\n */\nexport class ObservableVariable extends Variable {\n\n\t#observer: ((x: Variable, v: number) => void) | null;\n\n\t// Called only from Problem.\n\tconstructor(d: Domain, observer: (x: Variable, v: number) => void) {\n\t\tsuper(d);\n\t\tthis.#observer = observer;\n\t}\n\n\t/**\n\t * Assign a value.\n\t * @param v Value.\n\t */\n\toverride assign(v: number): void {\n\t\tsuper.assign(v);\n\t\tif (this.#observer) {\n\t\t\tthis.#observer(this, v);\n\t\t}\n\t}\n\n}\n\n/**\n * Class that represents an imaginary variable.\n */\nexport class ImaginaryVariable extends Variable {\n\n\t#orig: Variable;\n\n\tconstructor(x: Variable) {\n\t\tsuper(x.domain());\n\t\tthis.#orig = x;\n\t\tthis.setName(x.name());\n\t\tthis.assign(x.value());\n\t}\n\n\toverride assign(v: number): void {\n\t\tthis.#orig.assign(v);\n\t}\n\n\toverride domain(): Domain;\n\n\toverride domain(d: Domain): void;\n\n\toverride domain(d?: Domain): Domain | void {\n\t\tif (d === undefined) {\n\t\t\treturn this.#orig.domain();\n\t\t} else {\n\t\t\tthis.#orig.domain(d);\n\t\t}\n\t}\n\n\toverride value(): number {\n\t\treturn this.#orig.value();\n\t}\n\n}\n", "/**\n * Relations.\n *\n * @author Takuto Yanagida\n * @version 2025-01-22\n */\n\nimport { Domain } from '../problem/domain';\n\n/**\n * Crisp relations defined by tables.\n */\nexport function createCrispTabledRelation(elms: (0 | 1)[], doms: Domain[]): (...vs: number[]) => number {\n\tconst es: (0 | 1)[] = [...elms];\n\tconst ds: Domain[]  = [...doms];\n\tconst ms: number[]  = new Array(doms.length);\n\n\tlet m: number = 1;\n\tfor (let i: number = ms.length - 1; i >= 0; --i) {\n\t\tms[i] = m;\n\t\tm *= ds[i].size();\n\t}\n\n\treturn (...vs: number[]): -1 | 0 | 1 => {\n\t\tif (ms.length !== vs.length) {\n\t\t\tthrow new RangeError();\n\t\t}\n\t\tlet index: number = 0;\n\t\tfor (let i: number = 0; i < ms.length; ++i) {\n\t\t\tindex += ms[i] * ds[i].indexOf(vs[i]);\n\t\t}\n\t\treturn es[index];\n\t};\n}\n\n/**\n * Fuzzy relations defined by tables.\n */\nexport function createFuzzyTabledRelation(elms: number[], doms: Domain[]): (...vs: number[]) => number {\n\tconst es: number[] = [...elms];\n\tconst ds: Domain[] = [...doms];\n\tconst ms = new Array(doms.length);\n\n\tlet m: number = 1;\n\tfor (let i: number = ms.length - 1; i >= 0; --i) {\n\t\tms[i] = m;\n\t\tm *= ds[i].size();\n\t}\n\n\treturn (...vs: number[]): number => {\n\t\tif (ms.length !== vs.length) {\n\t\t\tthrow new RangeError();\n\t\t}\n\t\tlet index: number = 0;\n\t\tfor (let i: number = 0; i < ms.length; ++i) {\n\t\t\tindex += ms[i] * ds[i].indexOf(vs[i]);\n\t\t}\n\t\treturn es[index];\n\t};\n}\n\n\n// -----------------------------------------------------------------------------\n\n\nexport function createCrispFuzzyRelation(fn: (...vs: number[]) => number, th: number): (...vs: number[]) => number {\n\treturn (...vs: number[]): -1 | 0 | 1 => {\n\t\tconst d: number = fn(...vs);\n\t\treturn (0 < d && d < th) ? 0 : d as -1 | 0 | 1;\n\t};\n}\n", "/**\n * Utility class for constraint satisfaction problems.\n *\n * @author Takuto Yanagida\n * @version 2025-01-22\n */\n\nimport { Problem } from '../problem/problem';\nimport { Variable } from '../problem/variable';\nimport { Constraint } from '../problem/constraint';\nimport { Domain } from '../problem/domain';\nimport { ImaginaryVariable } from './variables';\nimport { createCrispFuzzyRelation } from './relations';\n\n/**\n * Create a table that caches constraints between two variables.\n * @param pro A problem.\n * @param xs  An array of variables.\n * @return A table that caches constraints between two variables.\n */\nexport function createRelatedConstraintTable(pro: Problem, xs: Variable[]): Constraint[][][] {\n\tconst rct: Constraint[][][] = [];\n\n\tfor (let j: number = 0; j < xs.length; ++j) {\n\t\trct.push(new Array(xs.length));\n\n\t\tfor (let i: number = 0; i < xs.length; ++i) {\n\t\t\tif (i < j) {\n\t\t\t\trct[j][i] = pro.constraintsBetween(xs[i], xs[j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn rct;\n}\n\n\n// -----------------------------------------------------------------------------\n\n\n/**\n * Calculates the average path length.\n * @param p A problem.\n * @return Average path length.\n */\nexport function averagePathLengths(p: Problem): number[] {\n\tconst ls = new Array(p.variableSize());\n\tfor (const x of p.variables()) {\n\t\tls[x.index()] = averagePathLength(p, x);\n\t}\n\treturn ls;\n}\n\n/**\n * Calculates the average path length for a given variable.\n * @param p A problem.\n * @param x A variable of the problem.\n * @return Average path length.\n */\nexport function averagePathLength(p: Problem, x: Variable): number {\n\tconst ls = new Array(p.variableSize());\n\tls.fill(Number.MAX_VALUE);\n\n\tconst xs = new Set<Variable>();\n\txs.add(x);\n\n\tls[x.index()] = 0;\n\tgetPathLength(p, x, ls, 0, xs);\n\n\tlet connectedSize: number = 0;\n\tlet sum: number = 0;\n\n\tfor (let i: number = 0; i < ls.length; ++i) {\n\t\tif (ls[i] !== Number.MAX_VALUE && i !== x.index()) {\n\t\t\t++connectedSize;\n\t\t\tsum += ls[i];\n\t\t}\n\t}\n\tif (0 === connectedSize) {\n\t\treturn 0;\n\t}\n\treturn sum / connectedSize;\n}\n\nfunction getPathLength(p: Problem, x: Variable, length: number[], baseLength: number, xo: Set<Variable>): void {\n\tconst xn: Variable[] = [];\n\n\tfor (const c of x) {\n\t\tfor (const xi of c) {\n\t\t\tif (length[xi.index()] === Number.MAX_VALUE) {\n\t\t\t\txn.push(xi);\n\t\t\t\tlength[xi.index()] = baseLength + 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (const xi of xn) {\n\t\txo.add(xi);\n\t}\n\tfor (const xi of xn) {\n\t\tgetPathLength(p, xi, length, baseLength + 1, xo);\n\t}\n}\n\n\n// -----------------------------------------------------------------------------\n\n\n/**\n * Gets an array containing all domains.\n * @param p A problem.\n * @return Array of domains.\n */\nexport function domains(p: Problem): Domain[] {\n\tconst ds: Domain[] = [];\n\tfor (const x of p.variables()) {\n\t\tds.push(x.domain());\n\t}\n\treturn ds;\n}\n\n/**\n * Set up all domains.\n * @param p A problem.\n * @param ds Array of domains.\n */\nexport function setDomains(p: Problem, ds: Domain[]): void {\n\tfor (let i: number = 0; i < ds.length; ++i) {\n\t\tp.variableAt(i).domain(ds[i]);\n\t}\n}\n\n\n// -----------------------------------------------------------------------------\n\n\n/**\n * Returns the array of possible satisfaction degree values for all unary constraints.\n * @param p A problem.\n * @param degrees Array of degree values.\n * @return The array.\n */\nexport function possibleDegreesOfUnaryConstraints(p: Problem, degrees: number[]): number[] {\n\tfor (const c of p.constraints()) {\n\t\tif (c.size() !== 1) continue;\n\t\tconst x: Variable = c.at(0) as Variable;\n\t\tconst origV: number = x.value();  // Save the value.\n\n\t\tfor (const v of x.domain()) {\n\t\t\tx.assign(v);\n\t\t\tdegrees.push(c.degree());\n\t\t}\n\t\tx.assign(origV);  // Restore the value.\n\t}\n\treturn degrees;\n}\n\n\n// -----------------------------------------------------------------------------\n\n\n/**\n * Returns a view of the fuzzy constraint satisfaction problem as a crisp constraint satisfaction problem.\n * The relations and domains of the specified fuzzy constraint satisfaction problem are reused, but the other elements are newly generated.\n * Note: Assignments to variables and changes to domains of the view are reflected in the variables of the original problem.\n * @param p A fuzzy constraint satisfaction problem.\n * @param threshold The threshold of constraint satisfaction degree. A constraint is considered satisfied when the constraint satisfaction degree is greater than or equal to this value.\n * @return A crisp constraint satisfaction problem.\n */\nexport function toViewAsCrispProblem(p: Problem, threshold: number): CrispFuzzyProblem {\n\tconst cp = new CrispFuzzyProblem();\n\n\tfor (const x of p.variables()) {\n\t\tcp.createVariable(x);\n\t}\n\tfor (const c of p.constraints()) {\n\t\tconst xs: Variable[] = [];\n\n\t\tfor (const x of c) {\n\t\t\txs.push(cp.variableAt(x.index()));\n\t\t}\n\t\tcp.createConstraint(createCrispFuzzyRelation(c.relation(), threshold), xs);\n\t}\n\treturn cp;\n}\n\nclass CrispFuzzyProblem extends Problem {\n\n\toverride createVariable(d_x: Domain | Variable, _value: number | null = null, _name: string = ''): Variable {\n\t\tif (d_x instanceof Variable) {\n\t\t\tconst iv = new ImaginaryVariable(d_x);\n\t\t\tthis.addVariable(iv);\n\t\t\treturn iv;\n\t\t}\n\t\tthrow new RangeError();\n\t}\n\n}\n", "/**\n * This class implements the forward and backward checking method for fuzzy CSP.\n * The minimum-remaining-values (MRV) heuristic can also be used by specifying the option.\n * Each variable must have its own domain because it hides domain elements as branch pruning.\n * Forward checking is also performed for problems with polynomial constraints.\n *\n * @author Takuto Yanagida\n * @version 2025-01-23\n */\n\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { Domain } from '../../problem/domain';\nimport { AssignmentList } from '../misc/assignment-list';\nimport { DomainPruner, indexOfVariableWithMRV } from '../misc/domain-pruner';\nimport { createRelatedConstraintTable } from '../../util/problems';\nimport { Solver } from '../solver';\n\nexport class FullChecking extends Solver {\n\n\t#xs! : Variable[];\n\t#rct!: Constraint[][][];  // Table to cache constraints between two variables.\n\t#dps!: DomainPruner[];\n\t#sol!: AssignmentList;\n\n\t#checkedCs!: Set<Constraint>;\n\t#sequence! : Variable[];\n\t#unaryCs!  : Constraint[];\n\n\t#minDeg!   : number;  // Degree of existing solutions (no need to find a solution less than this).\n\t#globalRet!: boolean;\n\n\t#useMRV          : boolean = true;\n\t#pruneIntensively: boolean = false;\n\n\t/**\n\t * Generates a solver.\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Specify whether to use the minimum-remaining-values (MRV) heuristic.\n\t * Use of MRV may increase processing time for some problems.\n\t * Default is false.\n\t * @param flag Use MRV if true.\n\t */\n\tsetUsingMinimumRemainingValuesHeuristics(flag: boolean): void {\n\t\tthis.#useMRV = flag;\n\t}\n\n\t/**\n\t * Specifies whether or not to intensively prune branches when the problem contains 3- or n-ary constraints.\n\t * Depending on the problem, intensive pruning may increase processing time.\n\t * Default is false.\n\t * @param flag Whether or not to intensively prune branches.\n\t */\n\tsetIntensivePruning(flag: boolean): void {\n\t\tthis.#pruneIntensively = flag;\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\toverride name(): string {\n\t\treturn 'Full Checking';\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override preprocess(): void {\n\t\tthis.#xs  = [...this.pro.variables()];\n\t\tthis.#rct = createRelatedConstraintTable(this.pro, this.#xs);\n\t\tthis.#dps = Array.from(this.#xs, (x: Variable): DomainPruner => new DomainPruner(x.domain().size()));\n\t\tthis.#sol = new AssignmentList();\n\n\t\tthis.#checkedCs = new Set();\n\t\tthis.#sequence  = new Array(this.pro.variableSize());\n\t\tthis.#unaryCs   = this.pro.constraints().filter((c: Constraint): boolean => c.size() === 1);\n\n\t\tthis.#minDeg = 0;\n\t\tthis.monitor.initialize();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override exec(): boolean {\n\t\tlet ret: boolean | null = null;\n\t\twhile (ret === null) {\n\t\t\tthis.#globalRet = false;\n\t\t\tthis.pro.clearAllVariables();\n\n\t\t\tif (!this.#pruneUnaryConstraints()) {\n\t\t\t\tret = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = this.#branch(0);\n\t\t\tthis.#sol.apply();\n\t\t}\n\n\t\treturn ret === true;\n\t}\n\n\t// Prune elements of the domain that make the unary constraint worse than the current worst degree.\n\t#pruneUnaryConstraints(): boolean {\n\t\tfor (const c of this.#unaryCs) {\n\t\t\tconst x    : Variable     = c.at(0) as Variable;\n\t\t\tconst origV: number       = x.value();  // Save the value.\n\t\t\tconst d    : Domain       = x.domain();\n\t\t\tconst dp   : DomainPruner = this.#dps[x.index()];\n\n\t\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\t\tx.assign(d.at(i));\n\t\t\t\tif (c.degree() <= this.#minDeg) {\n\t\t\t\t\tdp.prune(i, -1);  // Here's a branch pruning!\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.assign(origV);  // Restore the value.\n\t\t\tif (dp.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t#branch(level: number, curDeg: number = 1): boolean | null {\n\t\tif (level === this.pro.variableSize()) {\n\t\t\tconst ev: number = this.pro.degree();\n\t\t\tthis.#sol.setProblem(this.pro);\n\t\t\tthis.monitor.outputDebugString('\\t' + `Evaluation ${ev}`);\n\n\t\t\tif (this.#minDeg < ev) {\n\t\t\t\tthis.#minDeg    = ev;\n\t\t\t\tthis.#globalRet = true;\n\n\t\t\t\tif (this.monitor.solutionFound(this.#sol, ev)) {\n\t\t\t\t\treturn true;  // Success.\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.monitor.check(ev);\n\t\t}\n\t\tlet ret: boolean | null = null;\n\t\tif (null !== (ret = this.monitor.check())) {\n\t\t\treturn ret;  // Success or failure.\n\t\t}\n\n\t\tconst x : Variable     = this.#xs[this.#useMRV ? indexOfVariableWithMRV(this.#xs, this.#dps) : level];\n\t\tconst d : Domain       = x.domain();\n\t\tconst dp: DomainPruner = this.#dps[x.index()];\n\n\t\tthis.#sequence[level] = x;\n\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\tif (dp.isPruned(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx.assign(d.at(i));\n\n\t\t\tconst deg: number = Math.min(curDeg, this.#getBackwardConsistency(x));\n\t\t\tif (deg <= this.#minDeg) {  // A new solution is assumed when 'greater than'.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (this.#checkForward(level, x)) {\n\t\t\t\tret = this.#branch(level + 1, deg);\n\t\t\t\tif (null !== ret || this.#globalRet) {  // Success or failure.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const dp of this.#dps) {\n\t\t\t\tdp.recover(level);\n\t\t\t}\n\t\t}\n\t\tif (ret === null) {  // When searching back to the parent, undo the branch pruning here.\n\t\t\tfor (const dp of this.#dps) {\n\t\t\t\tdp.recover(level);\n\t\t\t}\n\t\t\tx.clear();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// Checks for possible assignment to a future variable from the current variable assignment.\n\t#checkForward(level: number, x: Variable): boolean {\n\t\tfor (const x_i of this.#xs) {\n\t\t\tif (!x_i.isEmpty()) {\n\t\t\t\tcontinue;  // If it is a past or present variable.\n\t\t\t}\n\t\t\tconst cs  : Constraint[] = this.#getConstraintsBetween(x.index(), x_i.index());\n\t\t\tconst dp_i: DomainPruner = this.#dps[x_i.index()];\n\t\t\tconst d_i : Domain       = x_i.domain();\n\n\t\t\tfor (const c of cs) {\n\t\t\t\tconst evs: number = c.emptySize();\n\t\t\t\tif (1 === evs) {\n\t\t\t\t\tif (!this.#checkForwardConsistency(level, x_i, d_i, dp_i, c)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else if (this.#pruneIntensively) {  // Depends on options\n\t\t\t\t\tif (2 === evs) {\n\t\t\t\t\t\tif (!this.#checkForwardConsistency2(level, x_i, d_i, dp_i, c)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (3 === evs) {\n\t\t\t\t\t\tif (!this.#checkForwardConsistency3(level, x_i, d_i, dp_i, c)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (3 < evs) {\n\t\t\t\t\t\tif (!this.#checkForwardConsistencyN(level, x_i, d_i, dp_i, c, evs)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Retrieves an array of constraints from a table that caches constraints between two variables.\n\t#getConstraintsBetween(i: number, j: number): Constraint[] {\n\t\treturn (i < j) ? this.#rct[j][i] : this.#rct[i][j];\n\t}\n\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there is one unassigned variable in the scope of the constraint).\n\t#checkForwardConsistency(level: number, x: Variable, d: Domain, dp: DomainPruner, c: Constraint): boolean {\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\tif (dp.isPruned(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx.assign(d.at(i));\n\n\t\t\tif (c.degree() <= this.#minDeg) {  // It is not a solution when it is 'smaller than or equals' (not even UNDEFINED).\n\t\t\t\tdp.prune(i, level);\n\t\t\t}\n\t\t}\n\t\tx.clear();\n\t\treturn !dp.isEmpty();  // Failure if the domain of one of the future variables is empty.\n\t}\n\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there are two unassigned variables in the scope of the constraint).\n\t#checkForwardConsistency2(level: number, x_i: Variable, d_i: Domain, dp_i: DomainPruner, c: Constraint): boolean {\n\t\tlet x_j: Variable | null = null;\n\n\t\tfor (const x of c) {\n\t\t\tif (x.isEmpty() && x !== x_i) {\n\t\t\t\tx_j = x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst d_j : Domain       = x_j!.domain();\n\t\tconst dp_j: DomainPruner = this.#dps[x_j!.index()];\n\n\t\tloop_i: for (let i: number = 0, ni: number = d_i.size(); i < ni; ++i) {\n\t\t\tif (dp_i.isPruned(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_i.assign(d_i.at(i));  // Tentative assignment to x_i\n\n\t\t\tfor (let j: number = 0, nj: number = d_j.size(); j < nj; ++j) {\n\t\t\t\tif (dp_j.isPruned(j)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tx_j!.assign(d_j.at(j));  // Tentative assignment to x_j\n\n\t\t\t\tif (this.#minDeg < c.degree()) {\n\t\t\t\t\tcontinue loop_i;  // Tentative assignment to x_i was OK -> next tentative assignment.\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp_i.prune(i, level);  // It is not a solution when it is 'smaller than or equals'.\n\t\t}\n\t\tx_j!.clear();\n\t\tx_i.clear();\n\t\treturn !dp_i.isEmpty();  // Succeeds if the domain di of the future variable is not empty.\n\t}\n\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there are three unassigned variables in the scope of the constraint).\n\t#checkForwardConsistency3(level: number, x_i: Variable, d_i: Domain, dp_i: DomainPruner, c: Constraint): boolean {\n\t\tlet x_j: Variable | null = null;\n\t\tlet x_k: Variable | null = null;\n\n\t\tfor (const x of c) {\n\t\t\tif (x.isEmpty() && x !== x_i) {\n\t\t\t\tif (x_j === null) {\n\t\t\t\t\tx_j = x;\n\t\t\t\t} else {\n\t\t\t\t\tx_k = x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst d_j : Domain       = x_j!.domain();\n\t\tconst d_k : Domain       = x_k!.domain();\n\t\tconst dp_j: DomainPruner = this.#dps[x_j!.index()];\n\t\tconst dp_k: DomainPruner = this.#dps[x_k!.index()];\n\n\t\tloop_i: for (let i: number = 0, ni: number = d_i.size(); i < ni; ++i) {\n\t\t\tif (dp_i.isPruned(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_i.assign(d_i.at(i));  // Tentative assignment to x_i\n\n\t\t\tfor (let j: number = 0, nj: number = d_j.size(); j < nj; ++j) {\n\t\t\t\tif (dp_j.isPruned(j)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tx_j!.assign(d_j.at(j));  // Tentative assignment to x_j\n\n\t\t\t\tfor (let k: number = 0, nk: number = d_k.size(); k < nk; ++k) {\n\t\t\t\t\tif (dp_k.isPruned(k)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tx_k!.assign(d_k.at(k));  // Tentative assignment to x_k\n\n\t\t\t\t\tif (this.#minDeg < c.degree()) {\n\t\t\t\t\t\tcontinue loop_i;  // Tentative assignment to x_i was OK -> next tentative assignment.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp_i.prune(i, level);  // It is not a solution when it is 'smaller than or equals'.\n\t\t}\n\t\tx_k!.clear();\n\t\tx_j!.clear();\n\t\tx_i.clear();\n\t\treturn !dp_i.isEmpty();  // Succeeds if the domain di of the future variable is not empty.\n\t}\n\n\t// In the case of polynomial constraints and when there are four or more unassigned variables, all combinations of assignments of unassigned variables are examined and pruned.\n\t#checkForwardConsistencyN(level: number, x_i: Variable, d_i: Domain, dp_i: DomainPruner, c: Constraint, emptySize: number): boolean {\n\t\tconst x_ = new Array(emptySize - 1);\n\t\tlet j: number = 0;\n\n\t\tfor (const x of c) {\n\t\t\tif (x.isEmpty() && x !== x_i) {\n\t\t\t\tx_[j++] = x;\n\t\t\t}\n\t\t}\n\t\tconst indexes = new Array(x_.length);\n\n\t\tloop_i: for (let i: number = 0, n: number = d_i.size(); i < n; ++i) {\n\t\t\tif (dp_i.isPruned(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_i.assign(d_i.at(i));  // Tentative assignment to x_i\n\t\t\tindexes.fill(0);\n\n\t\t\tcomLoop: while (true) {\n\t\t\t\tlet hidden: boolean = false;\n\n\t\t\t\tfor (let k: number = 0; k < x_.length; ++k) {\n\t\t\t\t\tconst d_k : Domain       = x_[k].domain();\n\t\t\t\t\tconst dp_k: DomainPruner = this.#dps[x_[k].index()];\n\n\t\t\t\t\tif (dp_k.isPruned(indexes[k])) {\n\t\t\t\t\t\thidden = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tx_[k].assign(d_k.at(indexes[k]));\n\t\t\t\t}\n\t\t\t\tif (!hidden) {\n\t\t\t\t\tif (this.#minDeg < c.degree()) {\n\t\t\t\t\t\tcontinue loop_i;  // Tentative assignment to x_i was OK -> next tentative assignment.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (let k: number = 0; k < x_.length; ++k) {\n\t\t\t\t\tindexes[k] += 1;\n\t\t\t\t\tif (indexes[k] < x_[k].domain().size()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexes[k] = 0;\n\t\t\t\t\tif (k === x_.length - 1) {\n\t\t\t\t\t\tbreak comLoop;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp_i.prune(i, level);\n\t\t}\n\t\tfor (const x of x_) {\n\t\t\tx.clear();\n\t\t}\n\t\tx_i.clear();\n\t\treturn !dp_i.isEmpty();  // Succeeds if the domain di of the future variable is not empty.\n\t}\n\n\t// Checks to see if the current variable assignment makes the degree of the past variable worse than the current worst degree.\n\t#getBackwardConsistency(x: Variable): number {\n\t\tlet min: number = Number.MAX_VALUE;\n\t\tthis.#checkedCs.clear();  // Reuse.\n\n\t\tfor (const x_i of this.#xs) {  // Find past variables.\n\t\t\tif (x_i === x || x_i.isEmpty()) {  // If it is a future variable or a present variable.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst cs: Constraint[] = this.#getConstraintsBetween(x.index(), x_i.index());\n\n\t\t\tfor (const c of cs) {\n\t\t\t\tif (!this.#checkedCs.has(c)) {  // Because of the possibility of duplication in polynomial constraints\n\t\t\t\t\tconst ev: number = c.degree();\n\t\t\t\t\tif (0 <= ev /* ev !== UNDEFINED */ && ev < min) {  // It is not a solution when it is 'smaller than or equals'.\n\t\t\t\t\t\tmin = ev;\n\t\t\t\t\t}\n\t\t\t\t\tthis.#checkedCs.add(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\n}\n", "/**\n * Class implements a solver using the breakout method for fuzzy CSP.\n *\n * @author Takuto Yanagida\n * @version 2025-01-22\n */\n\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { Assignment } from '../misc/assignment';\nimport { AssignmentList } from '../misc/assignment-list';\nimport { Solver } from '../solver';\n\nexport class FuzzyBreakout extends Solver {\n\n\t#isRandom: boolean = true;\n\t#ws!     : number[];\n\n\t/**\n\t * Generates a solver.\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Sets the randomness of the algorithm.\n\t * Enabling randomness reduces the risk of local solutions, but makes the solution unrepeatable.\n\t * @param flag Whether the randomness is enabled.\n\t */\n\tsetRandomness(flag: boolean): void {\n\t\tthis.#isRandom = flag;\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\toverride name(): string {\n\t\treturn 'Fuzzy Breakout';\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override preprocess(): void {\n\t\tthis.#ws = new Array(this.pro.constraintSize());\n\t\tthis.#ws.fill(1);\n\n\t\tfor (const x of this.pro.variables()) {\n\t\t\tif (x.isEmpty()) {\n\t\t\t\tx.assign(x.domain().at(0));\n\t\t\t}\n\t\t}\n\t\tthis.monitor.initialize();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override exec(): boolean {\n\t\tconst defEv: number         = this.pro.degree();\n\t\tconst sol  : AssignmentList = new AssignmentList();\n\t\tlet solEv  : number         = defEv;\n\n\t\tconst canList = new AssignmentList();\n\t\tlet ret: boolean | null = null;\n\n\t\twhile (true) {\n\t\t\tconst [cs, ev] = this.pro.constraintsWithDegree();\n\t\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\n\n\t\t\tif (solEv < ev) {\n\t\t\t\tsol.setProblem(this.pro);\n\t\t\t\tsolEv = ev;\n\n\t\t\t\tif (this.monitor.solutionFound(sol, solEv)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (null !== (ret = this.monitor.check(ev))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.#next(cs, canList);\n\t\t}\n\n\t\tif (false === ret && !this.monitor.isTargetAssigned() && defEv < solEv) {\n\t\t\tsol.apply();\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t#next(cs: Constraint[], canList: AssignmentList): void {\n\t\tthis.#findCandidates(this.#listTargetVariables(cs), canList);\n\n\t\tif (0 < canList.size()) {\n\t\t\tconst a: Assignment = this.#isRandom ? canList.random() : canList.at(0);\n\t\t\ta.apply();\n\t\t\tcanList.clear();\n\t\t\tthis.monitor.outputDebugString('\\t' + a);\n\t\t} else {\n\t\t\tfor (const c of cs) {\n\t\t\t\tthis.#ws[c.index()] += 1;\n\t\t\t}\n\t\t\tthis.monitor.outputDebugString('Breakout');\n\t\t}\n\t}\n\n\t#findCandidates(tarXs: Variable[], canList: AssignmentList): void {\n\t\tlet maxDiff: number = 0;\n\n\t\tfor (const x of tarXs) {\n\t\t\tconst x_v: number = x.value();  // Save the value\n\n\t\t\tlet nowEv: number = 0;\n\t\t\tfor (const c of x) {\n\t\t\t\tnowEv += (1 - c.degree()) * this.#ws[c.index()];\n\t\t\t}\n\t\t\tout: for (const v of x.domain()) {\n\t\t\t\tif (x_v === v) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tx.assign(v);\n\t\t\t\tlet diff: number = nowEv;\n\n\t\t\t\tfor (const c of x) {\n\t\t\t\t\tdiff -= (1 - c.degree()) * this.#ws[c.index()];\n\t\t\t\t\t// If the improvement is less than the previous improvement, try the next variable.\n\t\t\t\t\tif (diff < maxDiff) {\n\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (maxDiff < diff) {  // An assignment that are better than ever before is found.\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tcanList.clear();\n\t\t\t\t\tcanList.addVariable(x, v);\n\t\t\t\t} else if (maxDiff !== 0) {  // An assignments that can be improved to the same level as before is found.\n\t\t\t\t\tcanList.addVariable(x, v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.assign(x_v);  // Restore the value.\n\t\t}\n\t}\n\n\t#listTargetVariables(tarCs: Constraint[]): Variable[] {\n\t\tconst xs = new Set<Variable>();\n\n\t\tfor (const c of tarCs) {\n\t\t\tfor (const x of c) {\n\t\t\t\txs.add(x);\n\t\t\t}\n\t\t}\n\t\treturn Array.from<Variable>(xs);\n\t}\n\n}\n", "/**\n * This class implements the forward checking method for fuzzy CSPs.\n * The minimum-remaining-values (MRV) heuristic can also be used by specifying the option.\n *\n * @author Takuto Yanagida\n * @version 2025-01-23\n */\n\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { Domain } from '../../problem/domain';\nimport { AssignmentList } from '../misc/assignment-list';\nimport { DomainPruner, indexOfVariableWithMRV } from '../misc/domain-pruner';\nimport { createRelatedConstraintTable } from '../../util/problems';\nimport { Solver } from '../solver';\n\nexport class FuzzyForwardChecking extends Solver {\n\n\t#xs! : Variable[];\n\t#rct!: Constraint[][][];  // Table to cache constraints between two variables.\n\t#dps!: DomainPruner[];\n\t#sol!: AssignmentList;\n\n\t#minDeg!   : number;  // Degree of existing solutions (no need to find a solution less than this).\n\t#globalRet!: boolean;\n\n\t#useMRV: boolean = true;\n\n\t/**\n\t * Generates a solver.\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Specify whether to use the minimum-remaining-values (MRV) heuristic.\n\t * Use of MRV may increase processing time for some problems.\n\t * Default is false.\n\t * @param flag Use MRV if true.\n\t */\n\tsetUsingMinimumRemainingValuesHeuristics(flag: boolean): void {\n\t\tthis.#useMRV = flag;\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\toverride name(): string {\n\t\treturn 'Fuzzy Forward Checking';\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override preprocess(): void {\n\t\tthis.#xs  = [...this.pro.variables()];\n\t\tthis.#rct = createRelatedConstraintTable(this.pro, this.#xs);\n\t\tthis.#dps = Array.from(this.#xs, (x: Variable): DomainPruner => new DomainPruner(x.domain().size()));\n\t\tthis.#sol = new AssignmentList();\n\n\t\tthis.#minDeg = 0;\n\t\tthis.monitor.initialize();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override exec(): boolean {\n\t\tlet ret: boolean | null = null;\n\t\twhile (ret === null) {\n\t\t\tthis.#globalRet = false;\n\t\t\tthis.pro.clearAllVariables();\n\n\t\t\tret = this.#branch(0);\n\t\t\tthis.#sol.apply();\n\t\t}\n\n\t\treturn ret === true;\n\t}\n\n\t#branch(level: number, curDeg: number = 1): boolean | null {\n\t\tif (level === this.pro.variableSize()) {\n\t\t\tconst ev: number = this.pro.degree();\n\t\t\tthis.#sol.setProblem(this.pro);\n\t\t\tthis.monitor.outputDebugString('\\t' + `Evaluation ${ev}`);\n\n\t\t\tif (this.#minDeg < ev) {\n\t\t\t\tthis.#minDeg    = ev;\n\t\t\t\tthis.#globalRet = true;\n\n\t\t\t\tif (this.monitor.solutionFound(this.#sol, ev)) {\n\t\t\t\t\treturn true;  // Success.\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.monitor.check(ev);\n\t\t}\n\t\tlet ret: boolean | null = null;\n\t\tif (null !== (ret = this.monitor.check())) {\n\t\t\treturn ret;  // Success or failure.\n\t\t}\n\n\t\tconst x : Variable     = this.#xs[this.#useMRV ? indexOfVariableWithMRV(this.#xs, this.#dps) : level];\n\t\tconst d : Domain       = x.domain();\n\t\tconst dp: DomainPruner = this.#dps[x.index()];\n\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\tif (dp.isPruned(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx.assign(d.at(i));\n\n\t\t\tconst deg: number = Math.min(curDeg, this.#getWorstDegreeAround(x));\n\t\t\tif (deg <= this.#minDeg) {  // A new solution is assumed when 'greater than'.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (this.#checkForward(level, x)) {\n\t\t\t\tret = this.#branch(level + 1, deg);\n\t\t\t\tif (null !== ret || this.#globalRet) {  // Success or failure.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const dp of this.#dps) {\n\t\t\t\tdp.recover(level);\n\t\t\t}\n\t\t}\n\t\tif (ret === null) {  // When searching back to the parent, undo the branch pruning here.\n\t\t\tfor (const dp of this.#dps) {\n\t\t\t\tdp.recover(level);\n\t\t\t}\n\t\t\tx.clear();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// Checks for possible assignment to a future variable from the current variable assignment.\n\t#checkForward(level: number, x: Variable): boolean {\n\t\tfor (const x_i of this.#xs) {\n\t\t\tif (!x_i.isEmpty()) {\n\t\t\t\tcontinue;  // If it is a past or present variable.\n\t\t\t}\n\t\t\tconst cs  : Constraint[] = this.#getConstraintsBetween(x.index(), x_i.index());\n\t\t\tconst dp_i: DomainPruner = this.#dps[x_i.index()];\n\t\t\tconst d_i : Domain       = x_i.domain();\n\n\t\t\tfor (const c of cs) {\n\t\t\t\tif (c.emptySize() !== 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!this.#checkForwardConsistency(level, x_i, d_i, dp_i, c)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Retrieves an array of constraints from a table that caches constraints between two variables.\n\t#getConstraintsBetween(i: number, j: number): Constraint[] {\n\t\treturn (i < j) ? this.#rct[j][i] : this.#rct[i][j];\n\t}\n\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there is one unassigned variable in the scope of the constraint).\n\t#checkForwardConsistency(level: number, x: Variable, d: Domain, dp: DomainPruner, c: Constraint): boolean {\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\tif (dp.isPruned(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx.assign(d.at(i));\n\n\t\t\tif (c.degree() <= this.#minDeg) {  // It is not a solution when it is 'smaller than or equals' (not even UNDEFINED).\n\t\t\t\tdp.prune(i, level);\n\t\t\t}\n\t\t}\n\t\tx.clear();\n\t\treturn !dp.isEmpty();  // Failure if the domain of one of the future variables is empty.\n\t}\n\n\t// Find the number of constraint violations that have increased due to the current value of the variable x.\n\t#getWorstDegreeAround(x: Variable): number {\n\t\tlet min: number = Number.MAX_VALUE;\n\n\t\tfor (const c of x) {\n\t\t\tconst ev: number = c.degree();\n\t\t\tif (0 <= ev /* ev !== UNDEFINED */ && ev < min) {\n\t\t\t\tmin = ev;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\n}\n", "/**\n * This class implements fuzzy GENET.\n * CSPs and FCSPs (but only Binary (F)CSPs) is supported.\n *\n * @author Takuto Yanagida\n * @version 2025-01-24\n */\n\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { AssignmentList } from '../misc/assignment-list';\nimport { rand } from '../misc/random';\nimport { Solver } from '../solver';\n\nexport class FuzzyGENET extends Solver {\n\n\t#clusters!   : Cluster[];\n\t#connections!: Connection[];\n\t#thDeg!      : number;\n\n\t/**\n\t * Generates a solver.\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Sets a threshold.\n\t *\n\t * @param threshold A threshold\n\t */\n\tsetThreshold(threshold: number): void {\n\t\tthis.#thDeg = threshold;\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\toverride name(): string {\n\t\treturn 'Fuzzy GENET';\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override preprocess(): void {\n\t\tthis.#clusters    = [];\n\t\tthis.#connections = [];\n\t\tthis.#thDeg\t      = 1;\n\n\t\tif (!this.#createNetwork()) {\n\t\t\tthrow new Error();\n\t\t}\n\t\tthis.monitor.initialize();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override exec(): boolean {\n\t\tconst order: number[] = [...Array(this.#clusters.length).keys()];\n\n\t\tconst defEv: number         = this.pro.degree();\n\t\tconst sol  : AssignmentList = new AssignmentList();\n\t\tlet solEv  : number         = defEv;\n\n\t\tlet ret: boolean | null = null;\n\n\t\twhile(true) {\n\t\t\tconst ev: number = this.pro.degree();\n\t\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\n\n\t\t\tif (solEv < ev) {\n\t\t\t\tsol.setProblem(this.pro);\n\t\t\t\tsolEv = ev;\n\n\t\t\t\tif (this.monitor.solutionFound(sol, solEv)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (null !== (ret = this.monitor.check(ev))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.#next(order);\n\t\t}\n\n\t\tif (false === ret && !this.monitor.isTargetAssigned() && defEv < solEv) {\n\t\t\tsol.apply();\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t#createNetwork(): boolean {\n\t\tthis.monitor.outputDebugString('Start of Network Generation');\n\t\tconst cons: Connection[] = [];\n\n\t\tfor (const x of this.pro.variables()) {\n\t\t\tif (x.domain().size() === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.#clusters.push(new Cluster(x));\n\t\t}\n\t\tfor (const c of this.pro.constraints()) {\n\t\t\tif (c.size() === 1) {  // In the case of unary constraints.\n\t\t\t\tconst x : Variable = c.at(0) as Variable;\n\t\t\t\tconst cl: Cluster  = this.#clusters[x.index()];\n\n\t\t\t\tfor (const n of cl) {\n\t\t\t\t\tconst origV: number = x.value();  // Save the value.\n\t\t\t\t\tx.assign(n._value);\n\n\t\t\t\t\tif (c.degree() <= this.#thDeg) {\n\t\t\t\t\t\tcons.push(new Connection(c, n));\n\t\t\t\t\t}\n\t\t\t\t\tx.assign(origV);  // Restore the value.\n\t\t\t\t}\n\t\t\t} else {  // In the case of binary constraints.\n\t\t\t\tconst x1  : Variable = c.at(0) as Variable;\n\t\t\t\tconst x2  : Variable = c.at(1) as Variable;\n\t\t\t\tconst cl_f: Cluster  = this.#clusters[x1.index()];\n\t\t\t\tconst cl_s: Cluster  = this.#clusters[x2.index()];\n\n\t\t\t\tfor (const n_f of cl_f) {\n\t\t\t\t\tconst origV1: number = x1.value();  // Save the value.\n\t\t\t\t\tx1.assign(n_f._value);\n\n\t\t\t\t\tfor (const n_s of cl_s) {\n\t\t\t\t\t\tconst origV2: number = x2.value();  // Save the value.\n\t\t\t\t\t\tx2.assign(n_s._value);\n\n\t\t\t\t\t\tif (c.degree() <= this.#thDeg) {\n\t\t\t\t\t\t\tcons.push(new Connection(c, n_f, n_s));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx2.assign(origV2);  // Restore the value.\n\t\t\t\t\t}\n\t\t\t\t\tx1.assign(origV1);  // Restore the value.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.#connections = cons;\n\t\tthis.monitor.outputDebugString('End of Network Generation');\n\t\treturn true;\n\t}\n\n\t#next(order: number[]): void {\n\t\tlet mod: boolean = false;\n\t\tfor (const i of this.#shuffle(order)) {\n\t\t\tif (this.#clusters[i].setActivityMaximumInput()) {\n\t\t\t\tmod = true; // Turn on the node with the largest input in each cluster\n\t\t\t}\n\t\t}\n\t\tif (!mod) { // When the local minimum solution is reached.\n\t\t\tfor (const con of this.#connections) {\n\t\t\t\tcon.refreshWeight(); // Update weights for all connections\n\t\t\t}\n\t\t\tthis.monitor.outputDebugString('\\tRefresh weights');\n\t\t} else {\n\t\t\tfor (const clu of this.#clusters) {\n\t\t\t\tclu.applyToVariable();\n\t\t\t}\n\t\t}\n\t}\n\n\t#shuffle(is: number[]): number[] {\n\t\tfor (let i: number = is.length - 1; 0 < i; --i) {\n\t\t\tconst j: number = rand(i + 1);\n\t\t\t[is[i], is[j]] = [is[j], is[i]];\n\t\t}\n\t\treturn is;\n\t}\n\n}\n\nclass Cluster {\n\n\t#x    : Variable;  // For avoiding a bug(?) of parcel.\n\t#index: number   = 0;\n\t#maxNs: number[] = [];\n\t_ns   : Neuron[] = [];\n\n\tconstructor(x: Variable) {\n\t\tthis.#x = x;\n\n\t\tfor (const v of x.domain()) {\n\t\t\tthis._ns.push(new Neuron(v));\n\t\t}\n\t\tthis.#setActivity(rand(this._ns.length));\n\t}\n\n\t#setActivity(index: number): void {\n\t\tfor (const n of this._ns) {\n\t\t\tn._isActive = false;\n\t\t}\n\t\tthis._ns[index]._isActive = true;\n\t\tthis.#index = index;\n\t}\n\n\tapplyToVariable(): void {\n\t\tthis.#x.assign(this._ns[this.#index]._value);\n\t}\n\n\t// Turn on the node with the largest input.\n\tsetActivityMaximumInput(): boolean {\n\t\tthis.#maxNs.length = 0;\n\n\t\tlet max      : number  = Number.NEGATIVE_INFINITY;\n\t\tlet alreadyOn: boolean = false;\n\n\t\tfor (let i: number = 0; i < this._ns.length; ++i) {\n\t\t\tconst input: number = this._ns[i].getInput();\n\n\t\t\tif (max <= input) {\n\t\t\t\tif (max < input) {\n\t\t\t\t\tmax = input;\n\t\t\t\t\tthis.#maxNs.length = 0;\n\t\t\t\t\talreadyOn = false;\n\t\t\t\t}\n\t\t\t\tthis.#maxNs.push(i);\n\t\t\t\tif (this.#index === i) {\n\t\t\t\t\talreadyOn = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (alreadyOn || 0 === this.#maxNs.length) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.#setActivity(this.#maxNs[rand(this.#maxNs.length)]);\n\t\treturn true;\n\t}\n\n\t[Symbol.iterator](): Iterator<Neuron> {\n\t\treturn this._ns[Symbol.iterator]();\n\t}\n\n}\n\nclass Connection {\n\n\t#c : Constraint;\n\t#n0: Neuron;\n\t#n1: Neuron | null;\n\t_w : number;  // Direct reference (read) allowed.\n\n\t// Order of neurons must be the same as the order of variables that the constraint has.\n\tconstructor(c: Constraint, first: Neuron, second: Neuron | null = null) {\n\t\tthis.#c  = c;\n\t\tthis.#n0 = first;\n\t\tthis.#n1 = second;\n\t\tthis._w  = c.degree() - 1;\n\n\t\tthis.#n0.addConnection(this);\n\t\tif (this.#n1) {\n\t\t\tthis.#n1.addConnection(this);\n\t\t}\n\t}\n\n\tgetNeuron(self: Neuron): Neuron | null {\n\t\tif (self === this.#n0) return this.#n1;\n\t\tif (self === this.#n1) return this.#n0;\n\t\treturn null;\n\t}\n\n\trefreshWeight(): void {\n\t\tif (!this.#n0._isActive || (this.#n1 !== null && !this.#n1._isActive)) {\n\t\t\treturn;\n\t\t}\n\t\tconst r: (...vs: number[]) => number = this.#c.relation();\n\t\tif (this.#c.size() === 1) {\n\t\t\tthis._w += (r(this.#n0._value) - 1);\n\t\t} else {\n\t\t\tthis._w += (r(this.#n0._value, (this.#n1 as Neuron)._value) - 1);\n\t\t}\n\t}\n\n}\n\nclass Neuron {\n\n\t#connections: Connection[] = [];\n\n\t_value   : number;  // Direct reference (read) allowed.\n\t_isActive: boolean = false;  // Direct reference (read, write) allowed.\n\n\tconstructor(value: number) {\n\t\tthis._value = value;\n\t}\n\n\taddConnection(c: Connection): void {\n\t\tthis.#connections.push(c);\n\t}\n\n\tgetInput(): number {\n\t\tlet ret: number = 0;\n\n\t\tfor (const c of this.#connections) {\n\t\t\tconst n: Neuron | null = c.getNeuron(this);  // If n is null, then the unary constraint.\n\t\t\tret += c._w * ((n === null || n._isActive) ? 1 : 0);\n\t\t}\n\t\treturn ret;\n\t}\n\n}\n", "/**\n * This class implements the SRS3 algorithm.\n *\n * @author Takuto Yanagida\n * @version 2025-01-24\n */\n\nimport { Constraint } from '../../problem/constraint';\nimport { Assignment } from '../misc/assignment';\nimport { AssignmentList } from '../misc/assignment-list';\nimport { rand } from '../misc/random';\nimport { Solver } from '../solver';\n\nexport class SRS3 extends Solver {\n\n\t#ws!: number[];\n\n\t#closedList!: Set<TreeNode>;\n\t#openList!  : Set<TreeNode>;  // LinkedHashSet is used in the original implementation.\n\t#nodes!     : TreeNode[];\n\t#neighbors! : (TreeNode[] | null)[];  // Cache\n\n\t#isRandom: boolean = true;\n\n\t/**\n\t * Generates a solver.\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Sets the randomness of the algorithm.\n\t * Enabling randomness reduces the risk of falling into a local solution, but makes the solution unrepeatable.\n\t * @param flag If true, randomness is enabled.\n\t */\n\tsetRandomness(flag: boolean): void {\n\t\tthis.#isRandom = flag;\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\toverride name(): string {\n\t\treturn 'SRS3';\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override preprocess(): void {\n\t\tthis.#ws = new Array(this.pro.constraintSize());\n\t\tthis.#ws.fill(1);\n\n\t\tthis.#closedList = new Set();\n\t\tthis.#openList   = new Set();\n\t\tthis.#nodes      = [];\n\t\tthis.#neighbors  = [];\n\n\t\tfor (const c of this.pro.constraints()) {\n\t\t\tthis.#nodes.push(new TreeNode(c));\n\t\t\tthis.#neighbors.push(null);\n\t\t}\n\n\t\tfor (const x of this.pro.variables()) {\n\t\t\tif (x.isEmpty()) {\n\t\t\t\tx.assign(x.domain().at(0));\n\t\t\t}\n\t\t}\n\t\tthis.monitor.initialize();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override exec(): boolean {\n\t\tconst defEv: number         = this.pro.degree();\n\t\tconst sol  : AssignmentList = new AssignmentList();\n\t\tlet solEv  : number         = defEv;\n\n\t\tlet ret: boolean | null = null;\n\n\t\twhile (true) {\n\t\t\tconst [cs, ev] = this.pro.constraintsWithDegree();\n\t\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\n\n\t\t\tif (solEv < ev) {\n\t\t\t\tsol.setProblem(this.pro);\n\t\t\t\tsolEv = ev;\n\n\t\t\t\tif (this.monitor.solutionFound(sol, solEv)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (null !== (ret = this.monitor.check(ev))) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (const tn of this.#nodes) {\n\t\t\t\ttn.clear();\n\t\t\t}\n\t\t\tconst c_stars = new Set<TreeNode>();\n\t\t\tfor (const c of cs) {\n\t\t\t\tconst tn: TreeNode = this.#nodes[c.index()];\n\t\t\t\tc_stars.add(tn);\n\t\t\t}\n\t\t\tthis.#srs(c_stars);\n\t\t}\n\n\t\tif (false === ret && !this.monitor.isTargetAssigned() && defEv < solEv) {\n\t\t\tsol.apply();\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t#srs(c_stars: Set<TreeNode>): boolean {\n\t\tthis.monitor.outputDebugString('SRS');\n\n\t\tthis.#closedList.clear();\n\t\tthis.#openList.clear();\n\t\tfor (const tn of c_stars) {\n\t\t\tthis.#openList.add(tn);\n\t\t}\n\n\t\twhile (c_stars.size && this.#openList.size) {\n\t\t\tconst node: TreeNode = this.#getElementFromSet(this.#openList);\n\t\t\tthis.#openList.delete(node);\n\n\t\t\tif (!this.#repair(node)) {\n\t\t\t\tthis.#spread(node);\n\t\t\t} else if (c_stars.delete(node)) {\n\t\t\t\t// If the repaired node is included in C* (to be deleted)\n\t\t\t} else if (node.parent() && this.#repair(node.parent() as TreeNode)) {\n\t\t\t\tthis.#shrink(node, c_stars);  // When its improvement leads to the improvement of its parents\n\t\t\t} else {\n\t\t\t\tthis.#spread(node);\n\t\t\t}\n\t\t}\n\t\treturn 0 === c_stars.size;\n\t}\n\n\t#spread(tn: TreeNode): void {\n\t\tthis.monitor.outputDebugString('Spread');\n\t\tthis.#closedList.add(tn);\n\n\t\tfor (const n of this.#getNeighbors(tn)) {\n\t\t\t// For constraints that are not included in Open or Closed.\n\t\t\tif (!this.#closedList.has(n) && !this.#openList.has(n)) {\n\t\t\t\tn.clear();\n\t\t\t\ttn.append(n);\n\t\t\t\tthis.#openList.add(n);\n\t\t\t}\n\t\t}\n\t}\n\n\t#repair(tn: TreeNode): boolean {\n\t\tthis.monitor.outputDebugString('Repair');\n\t\tconst c0: Constraint = tn.constraint();\n\n\t\tlet tn0: TreeNode = tn;\n\t\tdo {\n\t\t\tthis.#ws[tn0.constraint().index()] += 1;\n\t\t} while (tn0 = tn0.parent() as TreeNode);\n\n\t\tconst defEv0: number = c0.degree();  // Target c0 should certainly be an improvement over this.\n\t\tconst canList = new AssignmentList();\n\t\tlet maxDiff: number = 0;\n\n\t\tfor (const x of c0) {\n\t\t\tconst x_v: number = x.value();  // Save the value\n\n\t\t\tlet nowEv: number = 0;\n\t\t\tfor (const c of x) {\n\t\t\t\tnowEv += (1 - c.degree()) * this.#ws[c.index()];\n\t\t\t}\n\t\t\tout: for (const v of x.domain()) {\n\t\t\t\tif (x_v === v) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tx.assign(v);\n\t\t\t\tif (c0.degree() <= defEv0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet diff: number = nowEv;\n\n\t\t\t\tfor (const c of x) {\n\t\t\t\t\tdiff -= (1 - c.degree()) * this.#ws[c.index()];\n\t\t\t\t\t// If the improvement is less than the previous improvement, try the next variable.\n\t\t\t\t\tif (diff < maxDiff) {\n\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (maxDiff < diff) {  // An assignment that are better than ever before is found.\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tcanList.clear();\n\t\t\t\t\tcanList.addVariable(x, v);\n\t\t\t\t} else if (maxDiff !== 0) {  // An assignments that can be improved to the same level as before is found.\n\t\t\t\t\tcanList.addVariable(x, v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.assign(x_v);  // Restore the value\n\t\t}\n\t\tif (0 < canList.size()) {\n\t\t\tconst a: Assignment = this.#isRandom ? canList.random() : canList.at(0);\n\t\t\ta.apply();\n\t\t\tthis.monitor.outputDebugString('\\t' + a);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t#shrink(node: TreeNode, c_stars: Set<TreeNode>): void {\n\t\tthis.monitor.outputDebugString('Shrink');\n\n\t\tlet cur         : TreeNode = node;\n\t\tlet curIsRemoved: boolean  = false;\n\n\t\twhile (true) {\n\t\t\tcur = cur.parent() as TreeNode;\n\t\t\tif (c_stars.delete(cur)) {\n\t\t\t\tcurIsRemoved = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!cur.parent() || !this.#repair(cur.parent() as TreeNode)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst temp: TreeNode[] = [];\n\t\tcur.getDescendants(temp);  // temp contains node.\n\t\tcur.clear();  // Prepare for reuse\n\n\t\tfor (const n of temp) {\n\t\t\tthis.#openList.delete(n);\n\t\t\tthis.#closedList.delete(n);\n\t\t}\n\t\tif (!curIsRemoved) {\n\t\t\tthis.#openList.add(cur);\n\t\t}\n\t}\n\n\t#getNeighbors(tn: TreeNode): TreeNode[] {\n\t\tconst c: Constraint = tn.constraint();\n\t\tconst i: number     = c.index();\n\n\t\tif (this.#neighbors[i] === null) {\n\t\t\tconst ns: TreeNode[] = [];\n\t\t\tfor (const d of c.neighbors()) {\n\t\t\t\tns.push(this.#nodes[d.index()]);\n\t\t\t}\n\t\t\tthis.#neighbors[i] = ns;\n\t\t}\n\t\treturn this.#neighbors[i];\n\t}\n\n\t#getElementFromSet(set: Set<TreeNode>): TreeNode {\n\t\tconst ms : TreeNode[] = this.#selectLightestNode(this.#selectNearestNode(set));\n\t\treturn this.#isRandom ? ms[rand(ms.length)] : ms[0];\n\t}\n\n\t#selectLightestNode(set: Iterable<TreeNode>): TreeNode[] {\n\t\tlet curW: number     = Number.MAX_VALUE;\n\t\tlet ms  : TreeNode[] = [];\n\n\t\tfor (const tn of set) {\n\t\t\tconst w: number = this.#ws[tn.constraint().index()];\n\t\t\tif (w < curW) {\n\t\t\t\tcurW = w;\n\t\t\t\tms.length = 0;\n\t\t\t\tms.push(tn);\n\t\t\t} else if (w === curW) {\n\t\t\t\tms.push(tn);\n\t\t\t}\n\t\t}\n\t\treturn ms;\n\t}\n\n\t#selectNearestNode(set: Iterable<TreeNode>): TreeNode[] {\n\t\tlet curD: number     = Number.MAX_VALUE;\n\t\tlet ms  : TreeNode[] = [];\n\n\t\tfor (const tn of set) {\n\t\t\tconst d: number = tn.depth();\n\t\t\tif (d < curD) {\n\t\t\t\tcurD = d;\n\t\t\t\tms.length = 0;\n\t\t\t\tms.push(tn);\n\t\t\t} else if (d === curD) {\n\t\t\t\tms.push(tn);\n\t\t\t}\n\t\t}\n\t\treturn ms;\n\t}\n\n}\n\nclass TreeNode {\n\n\t#c       : Constraint;\n\t#depth   : number = 0;\n\t#parent  : TreeNode | null = null;\n\t#children: TreeNode[] = [];\n\n\tconstructor(c: Constraint) {\n\t\tthis.#c = c;\n\t}\n\n\tappend(tn: TreeNode): void {\n\t\ttn.#parent = this;\n\t\ttn.#depth  = this.#depth + 1;\n\t\tthis.#children.push(tn);\n\t}\n\n\tclear(): void {\n\t\tthis.#parent = null;\n\t\tthis.#depth  = 0;\n\t\tfor (const tn of this.#children) {\n\t\t\ttn.clear();\n\t\t}\n\t\tthis.#children.length = 0;\n\t}\n\n\tconstraint(): Constraint {\n\t\treturn this.#c;\n\t}\n\n\tdepth(): number {\n\t\treturn this.#depth;\n\t}\n\n\tparent(): TreeNode | null {\n\t\treturn this.#parent;\n\t}\n\n\tgetDescendants(tns: TreeNode[]): void {\n\t\ttns.push(this);\n\n\t\tfor (const tn of this.#children) {\n\t\t\ttn.getDescendants(tns);\n\t\t}\n\t}\n\n}\n", "/**\n * Class implements a solver using the breakout method.\n * Solves a problem as a maximum CSP.\n *\n * @author Takuto Yanagida\n * @version 2025-01-23\n */\n\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { Assignment } from '../misc/assignment';\nimport { AssignmentList } from '../misc/assignment-list';\nimport { Solver } from '../solver';\n\nexport class Breakout extends Solver {\n\n\t#isRandom: boolean = true;\n\t#ws!     : number[];\n\n\t/**\n\t * Generates a solver.\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Sets the randomness of the algorithm.\n\t * Enabling randomness reduces the risk of local solutions, but makes the solution unrepeatable.\n\t * @param flag Whether the randomness is enabled.\n\t */\n\tsetRandomness(flag: boolean): void {\n\t\tthis.#isRandom = flag;\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\toverride name(): string {\n\t\treturn 'Breakout';\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override preprocess(): void {\n\t\tthis.#ws = new Array(this.pro.constraintSize());\n\t\tthis.#ws.fill(1);\n\n\t\tfor (const x of this.pro.variables()) {\n\t\t\tif (x.isEmpty()) {\n\t\t\t\tx.assign(x.domain().at(0));\n\t\t\t}\n\t\t}\n\t\tthis.monitor.initialize();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override exec(): boolean {\n\t\tconst defEv: number         = this.pro.ratio();\n\t\tconst sol  : AssignmentList = new AssignmentList();\n\t\tlet solEv  : number         = defEv;\n\n\t\tconst canList = new AssignmentList();\n\t\tlet ret: boolean | null = null;\n\n\t\twhile (true) {\n\t\t\tconst cs: Constraint[] = this.pro.violatingConstraints();\n\t\t\tconst ev: number = this.pro.ratio();\n\t\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\n\n\t\t\tif (solEv < ev) {\n\t\t\t\tsol.setProblem(this.pro);\n\t\t\t\tsolEv = ev;\n\n\t\t\t\tif (this.monitor.solutionFound(sol, solEv)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (null !== (ret = this.monitor.check(ev))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.#next(cs, canList);\n\t\t}\n\n\t\tif (false === ret && !this.monitor.isTargetAssigned() && defEv < solEv) {\n\t\t\tsol.apply();\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t#next(cs: Constraint[], canList: AssignmentList): void {\n\t\tthis.#findCandidates(this.#listTargetVariables(cs), canList);\n\n\t\tif (0 < canList.size()) {\n\t\t\tconst a: Assignment = this.#isRandom ? canList.random() : canList.at(0);\n\t\t\ta.apply();\n\t\t\tcanList.clear();\n\t\t\tthis.monitor.outputDebugString('\\t' + a);\n\t\t} else {\n\t\t\tfor (const c of cs) {\n\t\t\t\tthis.#ws[c.index()] += 1;\n\t\t\t}\n\t\t\tthis.monitor.outputDebugString('Breakout');\n\t\t}\n\t}\n\n\t#findCandidates(tarXs: Variable[], canList: AssignmentList): void {\n\t\tlet maxDiff: number = 0;\n\n\t\tfor (const x of tarXs) {\n\t\t\tconst x_v: number = x.value();  // Save the value\n\n\t\t\tlet nowEv: number = 0;\n\t\t\tfor (const c of x) {\n\t\t\t\tnowEv += (1 - c.status()) * this.#ws[c.index()];\n\t\t\t}\n\t\t\tout: for (const v of x.domain()) {\n\t\t\t\tif (x_v === v) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tx.assign(v);\n\t\t\t\tlet diff: number = nowEv;\n\n\t\t\t\tfor (const c of x) {\n\t\t\t\t\tdiff -= (1 - c.status()) * this.#ws[c.index()];\n\t\t\t\t\t// If the improvement is less than the previous improvement, try the next variable.\n\t\t\t\t\tif (diff < maxDiff) {\n\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (maxDiff < diff) {  // An assignment that are better than ever before is found.\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tcanList.clear();\n\t\t\t\t\tcanList.addVariable(x, v);\n\t\t\t\t} else if (maxDiff !== 0) {  // An assignments that can be improved to the same level as before is found.\n\t\t\t\t\tcanList.addVariable(x, v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.assign(x_v);  // Restore the value.\n\t\t}\n\t}\n\n\t#listTargetVariables(tarCs: Constraint[]): Variable[] {\n\t\tconst xs = new Set<Variable>();\n\n\t\tfor (const c of tarCs) {\n\t\t\tfor (const x of c) {\n\t\t\t\txs.add(x);\n\t\t\t}\n\t\t}\n\t\treturn Array.from<Variable>(xs);\n\t}\n\n}\n", "/**\n * This class implements the SRS3 algorithm for crisp CSP.\n * The given crisp CSP is treated as the maximum CSP.\n *\n * @author Takuto Yanagida\n * @version 2025-01-24\n */\n\nimport { Constraint } from '../../problem/constraint';\nimport { Assignment } from '../misc/assignment';\nimport { AssignmentList } from '../misc/assignment-list';\nimport { rand } from '../misc/random';\nimport { Solver } from '../solver';\n\nexport class CrispSRS3 extends Solver {\n\n\t#ws!: number[];\n\n\t#closedList!: Set<TreeNode>;\n\t#openList!  : Set<TreeNode>;  // LinkedHashSet is used in the original implementation.\n\t#nodes!     : TreeNode[];\n\t#neighbors! : (TreeNode[] | null)[];  // Cache\n\n\t#isRandom: boolean = true;\n\n\t/**\n\t * Generates a solver.\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Sets the randomness of the algorithm.\n\t * Enabling randomness reduces the risk of falling into a local solution, but makes the solution unrepeatable.\n\t * @param flag If true, randomness is enabled.\n\t */\n\tsetRandomness(flag: boolean): void {\n\t\tthis.#isRandom = flag;\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\toverride name(): string {\n\t\treturn 'Crisp SRS3';\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override preprocess(): void {\n\t\tthis.#ws = new Array(this.pro.constraintSize());\n\t\tthis.#ws.fill(1);\n\n\t\tthis.#closedList = new Set();\n\t\tthis.#openList   = new Set();\n\t\tthis.#nodes      = [];\n\t\tthis.#neighbors  = [];\n\n\t\tfor (const c of this.pro.constraints()) {\n\t\t\tthis.#nodes.push(new TreeNode(c));\n\t\t\tthis.#neighbors.push(null);\n\t\t}\n\n\t\tfor (const x of this.pro.variables()) {\n\t\t\tif (x.isEmpty()) {\n\t\t\t\tx.assign(x.domain().at(0));\n\t\t\t}\n\t\t}\n\t\tthis.monitor.initialize();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override exec(): boolean {\n\t\tconst defEv: number         = this.pro.degree();\n\t\tconst sol  : AssignmentList = new AssignmentList();\n\t\tlet solEv  : number         = defEv;\n\n\t\tlet ret: boolean | null = null;\n\n\t\twhile (true) {\n\t\t\tconst cs: Constraint[] = this.pro.violatingConstraints();\n\t\t\tconst ev: number = this.pro.ratio();\n\t\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\n\n\t\t\tif (solEv < ev) {\n\t\t\t\tsol.setProblem(this.pro);\n\t\t\t\tsolEv = ev;\n\n\t\t\t\tif (this.monitor.solutionFound(sol, solEv)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (null !== (ret = this.monitor.check(ev))) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (const tn of this.#nodes) {\n\t\t\t\ttn.clear();\n\t\t\t}\n\t\t\tconst c_stars = new Set<TreeNode>();\n\t\t\tfor (const c of cs) {\n\t\t\t\tconst tn: TreeNode = this.#nodes[c.index()];\n\t\t\t\tc_stars.add(tn);\n\t\t\t}\n\t\t\tthis.#srs(c_stars);\n\t\t}\n\n\t\tif (false === ret && !this.monitor.isTargetAssigned() && defEv < solEv) {\n\t\t\tsol.apply();\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t#srs(c_stars: Set<TreeNode>): boolean {\n\t\tthis.monitor.outputDebugString('SRS');\n\n\t\tthis.#closedList.clear();\n\t\tthis.#openList.clear();\n\t\tfor (const tn of c_stars) {\n\t\t\tthis.#openList.add(tn);\n\t\t}\n\n\t\twhile (c_stars.size && this.#openList.size) {\n\t\t\tconst node: TreeNode = this.#getElementFromSet(this.#openList);\n\t\t\tthis.#openList.delete(node);\n\n\t\t\tif (!this.#repair(node)) {\n\t\t\t\tthis.#spread(node);\n\t\t\t} else if (c_stars.delete(node)) {\n\t\t\t\t// If the repaired node is included in C* (to be deleted)\n\t\t\t} else if (node.parent() && this.#repair(node.parent() as TreeNode)) {\n\t\t\t\tthis.#shrink(node, c_stars);  // When its improvement leads to the improvement of its parents\n\t\t\t} else {\n\t\t\t\tthis.#spread(node);\n\t\t\t}\n\t\t}\n\t\treturn 0 === c_stars.size;\n\t}\n\n\t#spread(tn: TreeNode): void {\n\t\tthis.monitor.outputDebugString('Spread');\n\t\tthis.#closedList.add(tn);\n\n\t\tfor (const n of this.#getNeighbors(tn)) {\n\t\t\t// For constraints that are not included in Open or Closed.\n\t\t\tif (!this.#closedList.has(n) && !this.#openList.has(n)) {\n\t\t\t\tn.clear();\n\t\t\t\ttn.append(n);\n\t\t\t\tthis.#openList.add(n);\n\t\t\t}\n\t\t}\n\t}\n\n\t#repair(tn: TreeNode): boolean {\n\t\tthis.monitor.outputDebugString('Repair');\n\t\tconst c0: Constraint = tn.constraint();\n\n\t\tlet tn0: TreeNode = tn;\n\t\tdo {\n\t\t\tthis.#ws[tn0.constraint().index()] += 1;\n\t\t} while (tn0 = tn0.parent() as TreeNode);\n\n\t\tconst canList = new AssignmentList();\n\t\tlet maxDiff: number = 0;\n\n\t\tfor (const x of c0) {\n\t\t\tconst x_v: number = x.value();  // Save the value\n\n\t\t\tlet nowEv: number = 0;\n\t\t\tfor (const c of x) {\n\t\t\t\tnowEv += (1 - c.status()) * this.#ws[c.index()];\n\t\t\t}\n\t\t\tout: for (const v of x.domain()) {\n\t\t\t\tif (x_v === v) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tx.assign(v);\n\t\t\t\tif (c0.status() !== 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet diff: number = nowEv;\n\n\t\t\t\tfor (const c of x) {\n\t\t\t\t\tdiff -= (1 - c.status()) * this.#ws[c.index()];\n\t\t\t\t\t// If the improvement is less than the previous improvement, try the next variable.\n\t\t\t\t\tif (diff < maxDiff) {\n\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (maxDiff < diff) {  // An assignment that are better than ever before is found.\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tcanList.clear();\n\t\t\t\t\tcanList.addVariable(x, v);\n\t\t\t\t} else if (maxDiff !== 0) {  // An assignments that can be improved to the same level as before is found.\n\t\t\t\t\tcanList.addVariable(x, v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.assign(x_v);  // Restore the value\n\t\t}\n\t\tif (0 < canList.size()) {\n\t\t\tconst a: Assignment = this.#isRandom ? canList.random() : canList.at(0);\n\t\t\ta.apply();\n\t\t\tthis.monitor.outputDebugString('\\t' + a);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t#shrink(node: TreeNode, c_stars: Set<TreeNode>): void {\n\t\tthis.monitor.outputDebugString('Shrink');\n\n\t\tlet cur         : TreeNode = node;\n\t\tlet curIsRemoved: boolean  = false;\n\n\t\twhile (true) {\n\t\t\tcur = cur.parent() as TreeNode;\n\t\t\tif (c_stars.delete(cur)) {\n\t\t\t\tcurIsRemoved = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!cur.parent() || !this.#repair(cur.parent() as TreeNode)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst temp: TreeNode[] = [];\n\t\tcur.getDescendants(temp);  // temp contains node.\n\t\tcur.clear();  // Prepare for reuse\n\n\t\tfor (const n of temp) {\n\t\t\tthis.#openList.delete(n);\n\t\t\tthis.#closedList.delete(n);\n\t\t}\n\t\tif (!curIsRemoved) {\n\t\t\tthis.#openList.add(cur);\n\t\t}\n\t}\n\n\t#getNeighbors(tn: TreeNode): TreeNode[] {\n\t\tconst c: Constraint = tn.constraint();\n\t\tconst i: number     = c.index();\n\n\t\tif (this.#neighbors[i] === null) {\n\t\t\tconst ns: TreeNode[] = [];\n\t\t\tfor (const d of c.neighbors()) {\n\t\t\t\tns.push(this.#nodes[d.index()]);\n\t\t\t}\n\t\t\tthis.#neighbors[i] = ns;\n\t\t}\n\t\treturn this.#neighbors[i];\n\t}\n\n\t#getElementFromSet(set: Set<TreeNode>): TreeNode {\n\t\tconst ms : TreeNode[] = this.#selectLightestNode(this.#selectNearestNode(set));\n\t\treturn this.#isRandom ? ms[rand(ms.length)] : ms[0];\n\t}\n\n\t#selectLightestNode(set: Iterable<TreeNode>): TreeNode[] {\n\t\tlet curW: number     = Number.MAX_VALUE;\n\t\tlet ms  : TreeNode[] = [];\n\n\t\tfor (const tn of set) {\n\t\t\tconst w: number = this.#ws[tn.constraint().index()];\n\t\t\tif (w < curW) {\n\t\t\t\tcurW = w;\n\t\t\t\tms.length = 0;\n\t\t\t\tms.push(tn);\n\t\t\t} else if (w === curW) {\n\t\t\t\tms.push(tn);\n\t\t\t}\n\t\t}\n\t\treturn ms;\n\t}\n\n\t#selectNearestNode(set: Iterable<TreeNode>): TreeNode[] {\n\t\tlet curD: number     = Number.MAX_VALUE;\n\t\tlet ms  : TreeNode[] = [];\n\n\t\tfor (const tn of set) {\n\t\t\tconst d: number = tn.depth();\n\t\t\tif (d < curD) {\n\t\t\t\tcurD = d;\n\t\t\t\tms.length = 0;\n\t\t\t\tms.push(tn);\n\t\t\t} else if (d === curD) {\n\t\t\t\tms.push(tn);\n\t\t\t}\n\t\t}\n\t\treturn ms;\n\t}\n\n}\n\nclass TreeNode {\n\n\t#c       : Constraint;\n\t#depth   : number = 0;\n\t#parent  : TreeNode | null = null;\n\t#children: TreeNode[] = [];\n\n\tconstructor(c: Constraint) {\n\t\tthis.#c = c;\n\t}\n\n\tappend(tn: TreeNode): void {\n\t\ttn.#parent = this;\n\t\ttn.#depth  = this.#depth + 1;\n\t\tthis.#children.push(tn);\n\t}\n\n\tclear(): void {\n\t\tthis.#parent = null;\n\t\tthis.#depth  = 0;\n\t\tfor (const tn of this.#children) {\n\t\t\ttn.clear();\n\t\t}\n\t\tthis.#children.length = 0;\n\t}\n\n\tconstraint(): Constraint {\n\t\treturn this.#c;\n\t}\n\n\tdepth(): number {\n\t\treturn this.#depth;\n\t}\n\n\tparent(): TreeNode | null {\n\t\treturn this.#parent;\n\t}\n\n\tgetDescendants(tns: TreeNode[]): void {\n\t\ttns.push(this);\n\n\t\tfor (const tn of this.#children) {\n\t\t\ttn.getDescendants(tns);\n\t\t}\n\t}\n\n}\n", "/**\n * This class that implements the forward checking method.\n * The minimum-remaining-values (MRV) heuristic can also be used by specifying the option.\n * Searches for variable assignments that satisfy all constraints and fails if none are found.\n * Each variable must have its own domain because it hides domain elements as branch pruning.\n *\n * @author Takuto Yanagida\n * @version 2025-01-23\n */\n\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { Domain } from '../../problem/domain';\nimport { AssignmentList } from '../misc/assignment-list';\nimport { DomainPruner, indexOfVariableWithMRV } from '../misc/domain-pruner';\nimport { createRelatedConstraintTable } from '../../util/problems';\nimport { Solver } from '../solver';\n\nexport class ForwardChecking extends Solver {\n\n\t#xs! : Variable[];\n\t#rct!: Constraint[][][];  // Table to cache constraints between two variables.\n\t#dps!: DomainPruner[];\n\t#sol!: AssignmentList;\n\n\t#useMRV: boolean = true;\n\n\t/**\n\t * Generates a solver.\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Specify whether to use the minimum-remaining-values (MRV) heuristic.\n\t * Use of MRV may increase processing time for some problems.\n\t * Default is false.\n\t * @param flag Use MRV if true.\n\t */\n\tsetUsingMinimumRemainingValuesHeuristics(flag: boolean): void {\n\t\tthis.#useMRV = flag;\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\toverride name(): string {\n\t\treturn 'Forward Checking';\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override preprocess(): void {\n\t\tthis.#xs  = [...this.pro.variables()];\n\t\tthis.#rct = createRelatedConstraintTable(this.pro, this.#xs);\n\t\tthis.#dps = Array.from(this.#xs, (x: Variable): DomainPruner => new DomainPruner(x.domain().size()));\n\t\tthis.#sol = new AssignmentList();\n\n\t\tthis.pro.clearAllVariables();\n\t\tthis.monitor.initialize();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override exec(): boolean {\n\t\tconst ret: boolean | null = this.#branch(0);\n\t\tthis.#sol.apply();\n\n\t\treturn ret === true;\n\t}\n\n\t#branch(level: number): boolean | null {\n\t\tif (level === this.pro.variableSize()) {\n\t\t\tconst ev: number = this.pro.ratio();\n\t\t\tthis.#sol.setProblem(this.pro);\n\t\t\tthis.monitor.outputDebugString('\\t' + `Evaluation ${ev}`);\n\n\t\t\tthis.monitor.solutionFound(this.#sol, ev);\n\t\t\treturn true;  // Success.\n\t\t}\n\t\tlet ret: boolean | null = null;\n\t\tif (null !== (ret = this.monitor.check())) {\n\t\t\treturn ret;  // Success or failure.\n\t\t}\n\n\t\tconst x : Variable     = this.#xs[this.#useMRV ? indexOfVariableWithMRV(this.#xs, this.#dps) : level];\n\t\tconst d : Domain       = x.domain();\n\t\tconst dp: DomainPruner = this.#dps[x.index()];\n\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\tif (dp.isPruned(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx.assign(d.at(i));\n\n\t\t\tconst vc: number = this.#getViolationCountAround(x);\n\t\t\tif (vc) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (this.#checkForward(level, x)) {\n\t\t\t\tret = this.#branch(level + 1);\n\t\t\t\tif (null !== ret) {  // Success or failure.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const dp of this.#dps) {\n\t\t\t\tdp.recover(level);\n\t\t\t}\n\t\t}\n\t\tif (ret === null) {  // When searching back to the parent, undo the branch pruning here.\n\t\t\tfor (const dp of this.#dps) {\n\t\t\t\tdp.recover(level);\n\t\t\t}\n\t\t\tx.clear();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// Checks for possible assignment to a future variable from the current variable assignment.\n\t#checkForward(level: number, x: Variable): boolean {\n\t\tfor (const x_i of this.#xs) {\n\t\t\tif (!x_i.isEmpty()) {\n\t\t\t\tcontinue;  // If it is a past or present variable.\n\t\t\t}\n\t\t\tconst cs  : Constraint[] = this.#getConstraintsBetween(x.index(), x_i.index());\n\t\t\tconst dp_i: DomainPruner = this.#dps[x_i.index()];\n\t\t\tconst d_i : Domain       = x_i.domain();\n\n\t\t\tfor (const c of cs) {\n\t\t\t\tif (c.emptySize() !== 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!this.#checkForwardConsistency(level, x_i, d_i, dp_i, c)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Retrieves an array of constraints from a table that caches constraints between two variables.\n\t#getConstraintsBetween(i: number, j: number): Constraint[] {\n\t\treturn (i < j) ? this.#rct[j][i] : this.#rct[i][j];\n\t}\n\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there is one unassigned variable in the scope of the constraint).\n\t#checkForwardConsistency(level: number, x: Variable, d: Domain, dp: DomainPruner, c: Constraint): boolean {\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\tif (dp.isPruned(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx.assign(d.at(i));\n\n\t\t\tif (c.status() === 0) {  // Do hide when in violation (not even UNDEFINED).\n\t\t\t\tdp.prune(i, level);\n\t\t\t}\n\t\t}\n\t\tx.clear();\n\t\treturn !dp.isEmpty();  // Failure if the domain of one of the future variables is empty.\n\t}\n\n\t// Find the number of constraint violations that have increased due to the current value of the variable x.\n\t#getViolationCountAround(x: Variable): number {\n\t\tlet vc: number = 0;\n\n\t\tfor (const c of x) {\n\t\t\tif (c.status() === 0) {  // Neither satisfied nor UNDEFINED.\n\t\t\t\t++vc;\n\t\t\t}\n\t\t}\n\t\treturn vc;\n\t}\n\n}\n", "/**\n * This class implements GENET.\n * CSP (but only Binary CSP) is supported.\n * Find the solution to the problem as the maximum CSP.\n *\n * @author Takuto Yanagida\n * @version 2025-01-24\n */\n\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { AssignmentList } from '../misc/assignment-list';\nimport { rand } from '../misc/random';\nimport { Solver } from '../solver';\n\nexport class GENET extends Solver {\n\n\t#clusters!   : Cluster[];\n\t#connections!: Connection[];\n\n\t/**\n\t * Generates a solver.\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\toverride name(): string {\n\t\treturn 'GENET';\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override preprocess(): void {\n\t\tthis.#clusters    = [];\n\t\tthis.#connections = [];\n\n\t\tif (!this.#createNetwork()) {\n\t\t\tthrow new Error();\n\t\t}\n\t\tthis.monitor.initialize();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override exec(): boolean {\n\t\tconst order: number[] = [...Array(this.#clusters.length).keys()];\n\n\t\tconst defEv: number         = this.pro.ratio();\n\t\tconst sol  : AssignmentList = new AssignmentList();\n\t\tlet solEv  : number         = defEv;\n\n\t\tlet ret: boolean | null = null;\n\n\t\twhile(true) {\n\t\t\tconst ev: number = this.pro.ratio();\n\t\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\n\n\t\t\tif (solEv < ev) {\n\t\t\t\tsol.setProblem(this.pro);\n\t\t\t\tsolEv = ev;\n\n\t\t\t\tif (this.monitor.solutionFound(sol, solEv)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (null !== (ret = this.monitor.check(ev))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.#next(order);\n\t\t}\n\n\t\tif (false === ret && !this.monitor.isTargetAssigned() && defEv < solEv) {\n\t\t\tsol.apply();\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t#createNetwork(): boolean {\n\t\tthis.monitor.outputDebugString('Start of Network Generation');\n\t\tconst cons: Connection[] = [];\n\n\t\tfor (const x of this.pro.variables()) {\n\t\t\tif (x.domain().size() === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.#clusters.push(new Cluster(x));\n\t\t}\n\t\tfor (const c of this.pro.constraints()) {\n\t\t\tif (c.size() === 1) {  // In the case of unary constraints.\n\t\t\t\tconst x : Variable = c.at(0) as Variable;\n\t\t\t\tconst cl: Cluster  = this.#clusters[x.index()];\n\n\t\t\t\tfor (const n of cl) {\n\t\t\t\t\tconst origV: number = x.value();  // Save the value.\n\t\t\t\t\tx.assign(n._value);\n\n\t\t\t\t\tif (c.status() !== 1) {\n\t\t\t\t\t\tcons.push(new Connection(c, n));\n\t\t\t\t\t}\n\t\t\t\t\tx.assign(origV);  // Restore the value.\n\t\t\t\t}\n\t\t\t} else {  // In the case of binary constraints.\n\t\t\t\tconst x1  : Variable = c.at(0) as Variable;\n\t\t\t\tconst x2  : Variable = c.at(1) as Variable;\n\t\t\t\tconst cl_f: Cluster  = this.#clusters[x1.index()];\n\t\t\t\tconst cl_s: Cluster  = this.#clusters[x2.index()];\n\n\t\t\t\tfor (const n_f of cl_f) {\n\t\t\t\t\tconst origV1: number = x1.value();  // Save the value.\n\t\t\t\t\tx1.assign(n_f._value);\n\n\t\t\t\t\tfor (const n_s of cl_s) {\n\t\t\t\t\t\tconst origV2: number = x2.value();  // Save the value.\n\t\t\t\t\t\tx2.assign(n_s._value);\n\n\t\t\t\t\t\tif (c.status() !== 1) {\n\t\t\t\t\t\t\tcons.push(new Connection(c, n_f, n_s));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx2.assign(origV2);  // Restore the value.\n\t\t\t\t\t}\n\t\t\t\t\tx1.assign(origV1);  // Restore the value.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.#connections = cons;\n\t\tthis.monitor.outputDebugString('End of Network Generation');\n\t\treturn true;\n\t}\n\n\t#next(order: number[]): void {\n\t\tlet mod: boolean = false;\n\t\tfor (const i of this.#shuffle(order)) {\n\t\t\tif (this.#clusters[i].setActivityMaximumInput()) {\n\t\t\t\tmod = true; // Turn on the node with the largest input in each cluster\n\t\t\t}\n\t\t}\n\t\tif (!mod) { // When the local minimum solution is reached.\n\t\t\tfor (const con of this.#connections) {\n\t\t\t\tcon.refreshWeight(); // Update weights for all connections\n\t\t\t}\n\t\t\tthis.monitor.outputDebugString('\\tRefresh weights');\n\t\t} else {\n\t\t\tfor (const clu of this.#clusters) {\n\t\t\t\tclu.applyToVariable();\n\t\t\t}\n\t\t}\n\t}\n\n\t#shuffle(is: number[]): number[] {\n\t\tfor (let i: number = is.length - 1; 0 < i; --i) {\n\t\t\tconst j: number = rand(i + 1);\n\t\t\t[is[i], is[j]] = [is[j], is[i]];\n\t\t}\n\t\treturn is;\n\t}\n\n}\n\nclass Cluster {\n\n\t#x    : Variable;  // For avoiding a bug(?) of parcel.\n\t#index: number   = 0;\n\t#maxNs: number[] = [];\n\t_ns   : Neuron[] = [];\n\n\tconstructor(x: Variable) {\n\t\tthis.#x = x;\n\n\t\tfor (const v of x.domain()) {\n\t\t\tthis._ns.push(new Neuron(v));\n\t\t}\n\t\tthis.#setActivity(rand(this._ns.length));\n\t}\n\n\t#setActivity(index: number): void {\n\t\tfor (const n of this._ns) {\n\t\t\tn._isActive = false;\n\t\t}\n\t\tthis._ns[index]._isActive = true;\n\t\tthis.#index = index;\n\t}\n\n\tapplyToVariable(): void {\n\t\tthis.#x.assign(this._ns[this.#index]._value);\n\t}\n\n\t// Turn on the node with the largest input.\n\tsetActivityMaximumInput(): boolean {\n\t\tthis.#maxNs.length = 0;\n\n\t\tlet max      : number  = Number.NEGATIVE_INFINITY;\n\t\tlet alreadyOn: boolean = false;\n\n\t\tfor (let i: number = 0; i < this._ns.length; ++i) {\n\t\t\tconst input: number = this._ns[i].getInput();\n\n\t\t\tif (max <= input) {\n\t\t\t\tif (max < input) {\n\t\t\t\t\tmax = input;\n\t\t\t\t\tthis.#maxNs.length = 0;\n\t\t\t\t\talreadyOn = false;\n\t\t\t\t}\n\t\t\t\tthis.#maxNs.push(i);\n\t\t\t\tif (this.#index === i) {\n\t\t\t\t\talreadyOn = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (alreadyOn || 0 === this.#maxNs.length) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.#setActivity(this.#maxNs[rand(this.#maxNs.length)]);\n\t\treturn true;\n\t}\n\n\t[Symbol.iterator](): Iterator<Neuron> {\n\t\treturn this._ns[Symbol.iterator]();\n\t}\n\n}\n\nclass Connection {\n\n\t#c : Constraint;\n\t#n0: Neuron;\n\t#n1: Neuron | null;\n\t_w : number;  // Direct reference (read) allowed.\n\n\t// Order of neurons must be the same as the order of variables that the constraint has.\n\tconstructor(c: Constraint, first: Neuron, second: Neuron | null = null) {\n\t\tthis.#c  = c;\n\t\tthis.#n0 = first;\n\t\tthis.#n1 = second;\n\t\tthis._w  = c.status() - 1;\n\n\t\tthis.#n0.addConnection(this);\n\t\tif (this.#n1) {\n\t\t\tthis.#n1.addConnection(this);\n\t\t}\n\t}\n\n\tgetNeuron(self: Neuron): Neuron | null {\n\t\tif (self === this.#n0) return this.#n1;\n\t\tif (self === this.#n1) return this.#n0;\n\t\treturn null;\n\t}\n\n\trefreshWeight(): void {\n\t\tif (!this.#n0._isActive || (this.#n1 !== null && !this.#n1._isActive)) {\n\t\t\treturn;\n\t\t}\n\t\tconst r: (...vs: number[]) => number = this.#c.relation();\n\t\tif (this.#c.size() === 1) {\n\t\t\tthis._w += (r(this.#n0._value) - 1);\n\t\t} else {\n\t\t\tthis._w += (r(this.#n0._value, (this.#n1 as Neuron)._value) - 1);\n\t\t}\n\t}\n\n}\n\nclass Neuron {\n\n\t#connections: Connection[] = [];\n\n\t_value   : number;  // Direct reference (read) allowed.\n\t_isActive: boolean = false;  // Direct reference (read, write) allowed.\n\n\tconstructor(value: number) {\n\t\tthis._value = value;\n\t}\n\n\taddConnection(c: Connection): void {\n\t\tthis.#connections.push(c);\n\t}\n\n\tgetInput(): number {\n\t\tlet ret: number = 0;\n\n\t\tfor (const c of this.#connections) {\n\t\t\tconst n: Neuron | null = c.getNeuron(this);  // If n is null, then the unary constraint.\n\t\t\tret += c._w * ((n === null || n._isActive) ? 1 : 0);\n\t\t}\n\t\treturn ret;\n\t}\n\n}\n", "/**\n * Class implements the local changes method.\n * The implementation is optimized by converting recursive calls to loops.\n *\n * @author Takuto Yanagida\n * @version 2025-01-23\n */\n\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { AssignmentList } from '../misc/assignment-list';\nimport { Solver } from '../solver';\n\nexport class LocalChanges extends Solver {\n\n\t#globalRet!: boolean;\n\n\t/**\n\t * Generates a solver.\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\toverride name(): string {\n\t\treturn 'Local Changes';\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override preprocess(): void {\n\t\tif (this.pro.emptySize() === 0) {\n\t\t\tthis.pro.clearAllVariables();\n\t\t}\n\t\tthis.#globalRet = false;\n\n\t\tthis.monitor.initialize();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override exec(): boolean {\n\t\tconst notFixed   = new Set<Variable>();\n\t\tconst unassigned = new Set<Variable>();\n\t\tfor (const x of this.pro.variables()) {\n\t\t\t(!x.isEmpty() ? notFixed : unassigned).add(x);\n\t\t}\n\n\t\tconst sol: AssignmentList = new AssignmentList();\n\t\tconst ret: boolean        = this.#lcVariables(new Set(), notFixed, unassigned);\n\n\t\tconst ev: number = this.pro.ratio();\n\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\n\n\t\tif (ret) {\n\t\t\tsol.setProblem(this.pro);\n\n\t\t\tif (this.monitor.solutionFound(sol, ev)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t#lcVariables(X1: Set<Variable>, X2: Set<Variable>, X3: Set<Variable>): boolean {\n\t\tX2 = new Set(X2);  // Clone\n\t\tX3 = new Set(X3);  // Clone\n\n\t\twhile (true) {\n\t\t\tthis.monitor.outputDebugString(`X1 ${X1.size}, X2' ${X2.size}, X3' ${X3.size}`);\n\n\t\t\tconst r: boolean | null = this.monitor.check(this.pro.degree());\n\t\t\tif (r !== null) {\n\t\t\t\tthis.#globalRet = true;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tif (0 === X3.size) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst x = X3.values().next().value as Variable;\n\t\t\tconst ret: boolean = this.#lcVariable(X1, X2, x);\n\n\t\t\tif (!ret || this.#globalRet) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tX2.add(x);\n\t\t\tX3.delete(x);\n\t\t}\n\t}\n\n\t#lcVariable(X1: Set<Variable>, X2: Set<Variable>, x: Variable): boolean {\n\t\tfor (const v of x.domain()) {\n\t\t\tconst al: AssignmentList = AssignmentList.fromVariables(X2);\n\t\t\tx.assign(v);\n\n\t\t\tconst ret: boolean = this.#lcValue(X1, X2, x);\n\t\t\tif (ret || this.#globalRet) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tx.clear();\n\t\t\tal.apply();\n\t\t}\n\t\treturn false;\n\t}\n\n\t#lcValue(X1: Set<Variable>, X2: Set<Variable>, x: Variable): boolean {\n\t\tif (!this.#isConsistent(X1, x, x.value())) {\n\t\t\treturn false;\n\t\t}\n\t\tconst X12: Set<Variable> = X1.union(X2);\n\t\tif (this.#isConsistent(X12, x, x.value())) {\n\t\t\treturn true;\n\t\t}\n\t\tconst X3: Set<Variable> = this.#createX3(X12, x, x.value());\n\n\t\tX1 = cloneAndAdd(X1, x);\n\t\tX2 = X2.difference(X3);\n\t\treturn this.#lcVariables(X1, X2, X3);\n\t}\n\n\t#isConsistent(A: Set<Variable>, x: Variable, v: number): boolean {\n\t\tconst cs = new Set<Constraint>();\n\n\t\tfor (const xa of A) {\n\t\t\tconst temp: Constraint[] = this.pro.constraintsBetween(x, xa);\n\t\t\tfor (const c of temp) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tconst origV: number = x.value();  // Save the value.\n\t\tx.assign(v);\n\n\t\tfor (const c of cs) {\n\t\t\tif (c.status() !== 1) {\n\t\t\t\tx.assign(origV);  // Restore the value.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tx.assign(origV);  // Restore the value.\n\t\treturn true;\n\t}\n\n\t#createX3(X12: Set<Variable>, x: Variable, v: number): Set<Variable> {\n\t\tconst newX3 = new Set<Variable>();\n\t\tconst cs    = new Set<Constraint>();\n\n\t\tfor (const xa of X12) {\n\t\t\tfor (const c of this.pro.constraintsBetween(x, xa)) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tconst origV: number = x.value();  // Save the value.\n\t\tx.assign(v);\n\n\t\tfor (const c of cs) {\n\t\t\tif (c.status() !== 1) {\n\t\t\t\tfor (const xi of c) {\n\t\t\t\t\tnewX3.add(xi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx.assign(origV);  // Restore the value.\n\t\tnewX3.delete(x);\n\t\treturn newX3;\n\t}\n\n}\n\nfunction cloneAndAdd<T>(s: Set<T>, e: T): Set<T> {\n\treturn new Set<T>(s).add(e);\n}\n", "/**\n * This class that implements the forward checking method.\n * The minimum-remaining-values (MRV) heuristic can also be used by specifying the option.\n * Find the solution to the problem as the maximum CSP.\n * Each variable must have its own domain because it hides domain elements as branch pruning.\n *\n * @author Takuto Yanagida\n * @version 2025-01-23\n */\n\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { Domain } from '../../problem/domain';\nimport { AssignmentList } from '../misc/assignment-list';\nimport { DomainPruner, indexOfVariableWithMRV } from '../misc/domain-pruner';\nimport { createRelatedConstraintTable } from '../../util/problems';\nimport { Solver } from '../solver';\n\nexport class MaxForwardChecking extends Solver {\n\n\t#xs! : Variable[];\n\t#rct!: Constraint[][][];  // Table to cache constraints between two variables.\n\t#dps!: DomainPruner[];\n\t#sol!: AssignmentList;\n\n\t#maxVc!: number;\n\n\t#useMRV: boolean = true;\n\n\t/**\n\t * Generates a solver.\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Specify whether to use the minimum-remaining-values (MRV) heuristic.\n\t * Use of MRV may increase processing time for some problems.\n\t * Default is false.\n\t * @param flag Use MRV if true.\n\t */\n\tsetUsingMinimumRemainingValuesHeuristics(flag: boolean): void {\n\t\tthis.#useMRV = flag;\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\toverride name(): string {\n\t\treturn 'Max Forward Checking';\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override preprocess(): void {\n\t\tthis.#xs  = [...this.pro.variables()];\n\t\tthis.#rct = createRelatedConstraintTable(this.pro, this.#xs);\n\t\tthis.#dps = Array.from(this.#xs, (x: Variable): DomainPruner => new DomainPruner(x.domain().size()));\n\t\tthis.#sol = new AssignmentList();\n\n\t\tthis.#maxVc = this.pro.constraintSize();\n\n\t\tthis.pro.clearAllVariables();\n\t\tthis.monitor.initialize();\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override exec(): boolean {\n\t\tconst ret: boolean | null = this.#branch(0);\n\t\tthis.#sol.apply();\n\n\t\treturn ret === true;\n\t}\n\n\t#branch(level: number, curVc: number = 0): boolean | null {\n\t\tif (level === this.pro.variableSize()) {\n\t\t\tconst ev: number = this.pro.ratio();\n\t\t\tthis.#sol.setProblem(this.pro);\n\t\t\tthis.monitor.outputDebugString('\\t' + `Evaluation ${ev}`);\n\n\t\t\tif (curVc < this.#maxVc) {\n\t\t\t\tthis.#maxVc = curVc;\n\n\t\t\t\tif (this.monitor.solutionFound(this.#sol, ev)) {\n\t\t\t\t\treturn true;  // Success.\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.monitor.check(ev);\n\t\t}\n\t\tlet ret: boolean | null = null;\n\t\tif (null !== (ret = this.monitor.check())) {\n\t\t\treturn ret;  // Success or failure.\n\t\t}\n\n\t\tconst x : Variable     = this.#xs[this.#useMRV ? indexOfVariableWithMRV(this.#xs, this.#dps) : level];\n\t\tconst d : Domain       = x.domain();\n\t\tconst dp: DomainPruner = this.#dps[x.index()];\n\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\tif (dp.isPruned(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx.assign(d.at(i));\n\n\t\t\tconst vc: number = curVc + this.#getViolationCountAround(x);\n\t\t\tif (this.#maxVc <= vc) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (curVc + 1 < this.#maxVc || this.#checkForward(level, x)) {\n\t\t\t\tret = this.#branch(level + 1, vc);\n\t\t\t\tif (null !== ret) {  // Success or failure.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const dp of this.#dps) {\n\t\t\t\tdp.recover(level);\n\t\t\t}\n\t\t}\n\t\tif (ret === null) {  // When searching back to the parent, undo the branch pruning here.\n\t\t\tfor (const dp of this.#dps) {\n\t\t\t\tdp.recover(level);\n\t\t\t}\n\t\t\tx.clear();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// Checks for possible assignment to a future variable from the current variable assignment.\n\t#checkForward(level: number, x: Variable): boolean {\n\t\tfor (const x_i of this.#xs) {\n\t\t\tif (!x_i.isEmpty()) {\n\t\t\t\tcontinue;  // If it is a past or present variable.\n\t\t\t}\n\t\t\tconst cs  : Constraint[] = this.#getConstraintsBetween(x.index(), x_i.index());\n\t\t\tconst dp_i: DomainPruner = this.#dps[x_i.index()];\n\t\t\tconst d_i : Domain       = x_i.domain();\n\n\t\t\tfor (const c of cs) {\n\t\t\t\tif (c.emptySize() !== 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!this.#checkForwardConsistency(level, x_i, d_i, dp_i, c)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Retrieves an array of constraints from a table that caches constraints between two variables.\n\t#getConstraintsBetween(i: number, j: number): Constraint[] {\n\t\treturn (i < j) ? this.#rct[j][i] : this.#rct[i][j];\n\t}\n\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there is one unassigned variable in the scope of the constraint).\n\t#checkForwardConsistency(level: number, x: Variable, d: Domain, dp: DomainPruner, c: Constraint): boolean {\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\tif (dp.isPruned(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx.assign(d.at(i));\n\n\t\t\tif (c.status() === 0) {  // Do hide when in violation (not even UNDEFINED).\n\t\t\t\tdp.prune(i, level);\n\t\t\t}\n\t\t}\n\t\tx.clear();\n\t\treturn !dp.isEmpty();  // Failure if the domain of one of the future variables is empty.\n\t}\n\n\t// Find the number of constraint violations that have increased due to the current value of the variable x.\n\t#getViolationCountAround(x: Variable): number {\n\t\tlet vc: number = 0;\n\n\t\tfor (const c of x) {\n\t\t\tif (c.status() === 0) {  // Neither satisfied nor UNDEFINED.\n\t\t\t\t++vc;\n\t\t\t}\n\t\t}\n\t\treturn vc;\n\t}\n\n}\n", "type Size = { width: number, height: number };\r\n\r\nexport abstract class Control {\r\n\r\n\t#degree: number;\r\n\t#minSize: Size = { width: 0, height: 0 };\r\n\t#maxSize: Size = { width: Number.MAX_SAFE_INTEGER, height: Number.MAX_SAFE_INTEGER };\r\n\t_owner: any;\r\n\r\n\tconstructor(owner: any, degree: number) {\r\n\t\tthis._owner = owner;\r\n\t\tthis.#degree = degree;\r\n\t}\r\n\r\n\tabstract name(): string;\r\n\r\n\tgetDegree(): number {\r\n\t\treturn this.#degree;\r\n\t}\r\n\r\n\taddPossibleDegreesTo(dest: Set<number>): void {\r\n\t\tdest.add(this.#degree);\r\n\t}\r\n\r\n\tsetMinimumSize(s: Size): void {\r\n\t\tthis.#minSize = { ...s };\r\n\t}\r\n\r\n\tgetMinimumSize(): Size {\r\n\t\treturn { ...this.#minSize };\r\n\t}\r\n\r\n\tsetMaximumSize(s: Size): void {\r\n\t\tthis.#maxSize = { ...s };\r\n\t}\r\n\r\n\tgetMaximumSize(): Size {\r\n\t\treturn { ...this.#maxSize };\r\n\t}\r\n\r\n}\r\n", "import { Control } from './control';\r\n\r\nexport class Button extends Control {\r\n\r\n\t#text: string;\r\n\r\n\tconstructor(owner: any, deg: number, text: string) {\r\n\t\tsuper(owner, deg);\r\n\t\tthis.#text = text;\r\n\r\n\t\tconst s = { width: this.#text.length + 2, height: 2 };\r\n\t\tthis.setMinimumSize(s);\r\n\t\tthis.setMaximumSize(s);\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'button';\r\n\t}\r\n\r\n}\r\n", "import { Control } from './control';\r\n\r\nexport class Checkbox extends Control {\r\n\r\n\t#text: string;\r\n\r\n\tconstructor(owner: any, deg: number, text: string) {\r\n\t\tsuper(owner, deg);\r\n\t\tthis.#text = text;\r\n\r\n\t\tconst s = { width: this.#text.length + 2, height: 1 };\r\n\t\tthis.setMinimumSize(s);\r\n\t\tthis.setMaximumSize(s);\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'checkbox';\r\n\t}\r\n\r\n}\r\n", "import { Control } from './control';\r\n\r\nexport class Checkboxes extends Control {\r\n\r\n\t#items: string[];\r\n\r\n\tconstructor(owner: any, deg: number, items: string[]) {\r\n\t\tsuper(owner, deg);\r\n\t\tthis.#items = [...items];\r\n\r\n\t\tlet maxLen: number = 0;\r\n\t\tfor (const it of items) {\r\n\t\t\tmaxLen = Math.max(maxLen, it.length);\r\n\t\t}\r\n\r\n\t\tconst s = { width: maxLen + 1, height: items.length * 1 };\r\n\t\tthis.setMinimumSize(s);\r\n\t\tthis.setMaximumSize(s);\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'checkboxes';\r\n\t}\r\n\r\n}\r\n", "import { Control } from './control';\r\n\r\nexport class Label extends Control {\r\n\r\n\t#text: string;\r\n\r\n\tconstructor(owner: any, deg: number, text: string) {\r\n\t\tsuper(owner, deg);\r\n\t\tthis.#text = text;\r\n\r\n\t\tconst s = { width: this.#text.length, height: 1 };\r\n\t\tthis.setMinimumSize(s);\r\n\t\tthis.setMaximumSize(s);\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'label';\r\n\t}\r\n\r\n}\r\n", "import { Layout } from './../layout/layout';\r\nimport { Control } from './control';\r\n\r\nexport class ListBox extends Control {\r\n\r\n\tstatic MIN_ITEM_SIZE: number = 4;\r\n\r\n\t#items: string[];\r\n\r\n\tstatic createVariableInstances(minDeg: number, maxDeg: number, items: string[]): [number, (owner: any) => Layout | Control][] {\r\n\t\tif (items.length <= ListBox.MIN_ITEM_SIZE) {\r\n\t\t\treturn [[maxDeg, (owner: any): any => new ListBox(owner, maxDeg, items, ListBox.MIN_ITEM_SIZE)]];\r\n\t\t}\r\n\t\tconst ret: [number, (owner: any) => any][] = [];\r\n\t\tconst rDeg: number = maxDeg - minDeg;\r\n\t\tfor (let i: number = ListBox.MIN_ITEM_SIZE + 1; i < items.length; ++i) {\r\n\t\t\tconst r: number = maxDeg + rDeg * (i / items.length - 1);\r\n\t\t\tconst count: number = i;\r\n\t\t\tret.push([r, (owner: any): any => new ListBox(owner, r, items, count)]);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tconstructor(owner: any, deg: number, items: string[], count: number = items.length) {\r\n\t\tsuper(owner, deg);\r\n\t\tthis.#items = [...items];\r\n\r\n\t\tconst minH: number = Math.min(count, ListBox.MIN_ITEM_SIZE) * 1;\r\n\r\n\t\tlet maxLen: number = 0;\r\n\t\tfor (const it of items) {\r\n\t\t\tmaxLen = Math.max(maxLen, it.length);\r\n\t\t}\r\n\r\n\t\tthis.setMinimumSize({ width: maxLen + 1, height: minH });\r\n\t\tthis.setMaximumSize({ width: Number.MAX_SAFE_INTEGER, height: Number.MAX_SAFE_INTEGER });\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'list box';\r\n\t}\r\n\r\n}\r\n", "import { Control } from './control';\r\n\r\nexport class RadioButtons extends Control {\r\n\r\n\t#items: string[];\r\n\r\n\tconstructor(owner: any, deg: number, items: string[]) {\r\n\t\tsuper(owner, deg);\r\n\t\tthis.#items = [...items];\r\n\r\n\t\tlet maxLen: number = 0;\r\n\t\tfor (const it of items) {\r\n\t\t\tmaxLen = Math.max(maxLen, it.length);\r\n\t\t}\r\n\r\n\t\tconst s = { width: maxLen + 1, height: items.length * 1 };\r\n\t\tthis.setMinimumSize(s);\r\n\t\tthis.setMaximumSize(s);\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'radio buttons';\r\n\t}\r\n\r\n}\r\n", "import { FElement } from '../f-element';\r\n\r\ntype Size = { width: number, height: number };\r\n\r\nexport abstract class Layout {\r\n\r\n\tstatic NO_DIR: number     = -1;\r\n\tstatic VERTICAL: number   = 0;\r\n\tstatic HORIZONTAL: number = 1;\r\n\r\n\t#owner: any;\r\n\t#degree: number;\r\n\t#direction: number;\r\n\r\n\tconstructor(owner: any, degree: number, direction: number = Layout.NO_DIR) {\r\n\t\tthis.#owner     = owner;\r\n\t\tthis.#degree    = degree;\r\n\t\tthis.#direction = direction;\r\n\t}\r\n\r\n\tabstract name(): string;\r\n\r\n\tgetOwner(): any {\r\n\t\treturn this.#owner;\r\n\t}\r\n\r\n\tgetDegree(): number {\r\n\t\treturn this.#degree;\r\n\t}\r\n\r\n\tgetDirection(): number {\r\n\t\treturn this.#direction;\r\n\t}\r\n\r\n\tgetEstimatedMinimumSize(children: FElement[]): Size {\r\n\t\tconst ss: Size[] = children.map(e => e.getEstimatedMinimumSize());\r\n\t\treturn this._calcSize(ss);\r\n\t}\r\n\r\n\tgetEstimatedMinimumSizeIf(children: FElement[], child: FElement, minSize: Size): Size {\r\n\t\tconst ss: Size[] = children.map(e => ((child === e) ? minSize : e.getEstimatedMinimumSize()));\r\n\t\treturn this._calcSize(ss);\r\n\t}\r\n\r\n\tgetMinimumSize(children: FElement[]): Size {\r\n\t\tconst ss: Size[] = children.map(e => e.getMinimumSize());\r\n\t\treturn this._calcSize(ss);\r\n\t}\r\n\r\n\tgetMaximumSize(): Size {\r\n\t\treturn { width: Number.MAX_SAFE_INTEGER, height: Number.MAX_SAFE_INTEGER };\r\n\t}\r\n\r\n\tabstract _calcSize(sizes: Size[]): Size;\r\n\r\n\tabstract doLayout(children: FElement[], size: Size): void;\r\n\r\n}\r\n", "export * from './src/problem/problem';\nexport * from './src/problem/element';\nexport * from './src/problem/variable';\nexport * from './src/problem/domain';\nexport * from './src/problem/constraint';\n\n\n// -----------------------------------------------------------------------------\n\n\nexport * from './src/solver/solver';\nexport * from './src/solver/monitor';\n\nexport * from './src/solver/fuzzy/flexible-local-changes';\nexport * from './src/solver/fuzzy/full-checking';\nexport * from './src/solver/fuzzy/fuzzy-breakout';\nexport * from './src/solver/fuzzy/fuzzy-forward-checking';\nexport * from './src/solver/fuzzy/fuzzy-genet';\nexport * from './src/solver/fuzzy/srs3';\n\nexport * from './src/solver/crisp/breakout';\nexport * from './src/solver/crisp/crisp-srs3';\nexport * from './src/solver/crisp/forward-checking';\nexport * from './src/solver/crisp/genet';\nexport * from './src/solver/crisp/local-changes';\nexport * from './src/solver/crisp/max-forward-checking';\n\nexport * from './src/solver/filter/ac3';\nexport * from './src/solver/filter/node-consistency';\nexport * from './src/solver/filter/post-stabilizer';\n\nexport * from './src/solver/misc/assignment';\nexport * from './src/solver/misc/assignment-list';\nexport * from './src/solver/misc/consistency';\nexport * from './src/solver/misc/domain-pruner';\nexport * from './src/solver/misc/random';\n\n\n// -----------------------------------------------------------------------------\n\n\nexport * from './src/util/loop-detector';\nexport * from './src/util/problems';\nexport * from './src/util/variables';\nexport * from './src/util/relations';\nexport * from './src/util/solver-factory';\n", "/**\n * Class of post-stabilization.\n *\n * @author Takuto Yanagida\n * @version 2025-01-23\n */\n\nimport { Problem } from '../../problem/problem';\nimport { Variable } from '../../problem/variable';\nimport { Assignment } from '../misc/assignment';\nimport { AssignmentList } from '../misc/assignment-list';\nimport { Solver } from '../solver';\n\n/**\n * Apply post-stabilization.\n *\n * @param p    Problem.\n * @param orig Original assignment list.\n * @param log  Log function.\n */\nexport function applyPostStabilization(p: Problem, orig: AssignmentList, log: (e: string) => void = (e: string): void => console.log(e)): boolean {\n\tlog('Start Post-Stabilization');\n\n\tlet stabilized: boolean;\n\tlet count: number = 0;\n\n\tdo {\n\t\tlog('\\tPost-Stabilization: count ' + count++);\n\n\t\tstabilized = false;\n\t\tlet ev_min: number = p.degree();\n\n\t\tconst xs: Variable[] = p.variables();\n\t\tfor (let i: number = 0; i < xs.length; ++i) {\n\t\t\tconst x: Variable = xs[i];\n\t\t\tconst v: number   = x.value();\n\n\t\t\tconst a: Assignment = orig.at(i);\n\t\t\tif (v === a.value()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta.apply();  // Try to assign the original.\n\t\t\tif (ev_min <= p.degree()) {\n\t\t\t\tstabilized = true;\n\t\t\t} else {\n\t\t\t\tx.assign(v);  // Restore.\n\t\t\t}\n\t\t}\n\t} while (stabilized);\n\n\tlog('Finish Post-Stabilization');\n\treturn stabilized;\n}\n\n/**\n * Wrap the solver with post-stabilizer.\n *\n * @param solver Solver.\n * @return Wrapped solver.\n */\nexport function wrapWithPostStabilizer(solver: Solver): Solver {\n\treturn new PostStabilizerWrapper(solver);\n}\n\n/**\n * Class of post-stabilizer wrapper.\n */\nexport class PostStabilizerWrapper extends Solver {\n\n\t#solver  : Solver;\n\t#criteria: Criteria;\n\n\tconstructor(solver: Solver, criteria: Criteria = Criteria.DEGREE) {\n\t\tsuper();\n\t\tthis.#solver   = solver;\n\t\tthis.#criteria = criteria;\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\toverride name(): string {\n\t\treturn this.#solver.name() + ' + PF';\n\t}\n\n\t/**\n\t * {@override}\n\t */\n\tprotected override exec(): boolean {\n\t\tlet ev : number = 0;\n\t\tlet evs: number = 0;\n\t\tif (this.monitor.isDebugMode()) {\n\t\t\tev  = Criteria.DEGREE === this.#criteria ? this.pro.degree() : this.pro.ratio();\n\t\t\tevs = this.pro.emptySize();\n\t\t}\n\t\tconst orig = new AssignmentList();\n\t\torig.setProblem(this.pro);\n\n\t\tconst res: boolean = this.#solver.solve(this.pro, this.monitor);\n\t\tif (res) {\n\t\t\tapplyPostStabilization(this.pro, orig, this.monitor.outputDebugString.bind(this.monitor));\n\t\t}\n\t\tthis.monitor.outputDebugString(`Solver result: ${res ? 'Success' : 'Failure'}`);\n\t\tthis.monitor.outputDebugString(`Evaluation: ${ev} -> ${Criteria.DEGREE === this.#criteria ? this.pro.degree() : this.pro.ratio()}`);\n\t\tthis.monitor.outputDebugString(`Empty variable size: ${evs} -> ${this.pro.emptySize()}`);\n\t\treturn res;\n\t}\n\n}\n\nconst Criteria = {\n\tDEGREE: 'degree',\n\tRATIO : 'ratio',\n};\n\nexport type Criteria = (typeof Criteria)[keyof typeof Criteria];\n", "import * as stlics from 'stlics/stlics';\r\nimport { FLayout } from './f-layout';\r\nimport { Layout } from './layout/layout';\r\nimport { Control } from './control/control';\r\n\r\ntype Size = { width: number, height: number };\r\ntype Pos = { x: number, y: number };\r\n\r\nexport abstract class FElement {\r\n\r\n\t#parent!: FLayout;\r\n\t#type!: stlics.Variable;\r\n\t#size: Size = { width: 0, height: 0 };\r\n\t#location: Pos = { x: 0, y: 0 };\r\n\r\n\t_estMinSize: Size = { width: Number.MAX_SAFE_INTEGER, height: Number.MAX_SAFE_INTEGER };\r\n\t_states: { comb: number[], size: Size }[] = [];\r\n\t_cans: (Layout | Control)[]       = [];\r\n\t_baseCans: (Layout | Control)[]   = [];\r\n\r\n\tname(): string {\r\n\t\treturn '';\r\n\t}\r\n\r\n\tsetParent(parent: FLayout): void {\r\n\t\tthis.#parent = parent;\r\n\t}\r\n\r\n\tgetParent(): FLayout {\r\n\t\treturn this.#parent;\r\n\t}\r\n\r\n\tgetVariable(): stlics.Variable {\r\n\t\treturn this.#type;\r\n\t}\r\n\r\n\r\n\t// -------------------------------------------------------------------------\r\n\r\n\r\n\tgetEstimatedMinimumSize(): Size {\r\n\t\treturn { ...this._estMinSize };\r\n\t}\r\n\r\n\t_getCandidateEntries(): [number, (e: FElement) => Layout | Control][] {\r\n\t\treturn [];\r\n\t}\r\n\r\n\t_assignCandidates(worstDeg: number, dest: (Layout | Control)[]): void {\r\n\t\tdest.length = 0;\r\n\t\tfor (const [d, e] of this._getCandidateEntries()) {\r\n\t\t\tif (worstDeg <= d) {\r\n\t\t\t\tdest.push(e(this));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tinitializeProblem(p: stlics.Problem): void {\r\n\t\tthis._assignCandidates(0, this._cans);\r\n\t\tthis._baseCans = [ ...this._cans ];\r\n\r\n\t\tthis.#type = p.createVariable(stlics.Domain.create([0]), 0, this.name() + ': type');\r\n\r\n\t\tp.createConstraint(\r\n\t\t\t(v0: number): number => this.#typeRelation(v0),\r\n\t\t\t[this.#type],\r\n\t\t\tthis.name() + ': type',\r\n\t\t);\r\n\t}\r\n\r\n\tabstract initializeEstimatedMinimumSize(): void;\r\n\r\n\tabstract initializeDomain(p: stlics.Problem): boolean;\r\n\r\n\tabstract addPossibleDegreesTo(dest: Set<number>): void;\r\n\r\n\tabstract setWorstDegree(deg: number): boolean;\r\n\r\n\t#typeRelation(val: number): number {\r\n\t\tif (this._states.length === 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tconst pc = this._typeToCandidate(val) as Layout | Control;\r\n\t\treturn pc.getDegree();\r\n\t}\r\n\r\n\t_typeToCandidate(val: number | null = null): Layout | Control | null {\r\n\t\tif (val === null && this.#type) {\r\n\t\t\tval = this.#type.value();\r\n\t\t}\r\n\t\tif (val !== null && this._states[val]) {\r\n\t\t\treturn this._cans[this._states[val].comb[0]] as Layout | Control;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tisValid(): boolean {\r\n\t\tif (!this.#type || this.#type.isEmpty()) return false;\r\n\t\tif (!this._states[this.#type.value()]) return false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t// -------------------------------------------------------------------------\r\n\r\n\r\n\tgetMinimumSize(): Size {\r\n\t\treturn { ...this._states[this.#type.value()].size };\r\n\t}\r\n\r\n\tgetMaximumSize(): Size {\r\n\t\treturn (this._typeToCandidate() as Layout | Control).getMaximumSize();\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the size of an element.\r\n\t * @return Size.\r\n\t */\r\n\tgetSize(): Size {\r\n\t\treturn { ...this.#size };\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the size of the element.\r\n\t * @param width Width.\r\n\t * @param height Height.\r\n\t */\r\n\tsetSize(width: number, height: number): void {\r\n\t\tthis.#size = { width, height };\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the element location.\r\n\t * @return Location.\r\n\t */\r\n\tgetLocation(): Pos {\r\n\t\treturn { ...this.#location };\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the location of the element.\r\n\t * @param x X.\r\n\t * @param y Y.\r\n\t */\r\n\tsetLocation(x: number, y: number): void {\r\n\t\tthis.#location = { x, y };\r\n\t}\r\n\r\n}\r\n", "import * as stlics from 'stlics/stlics';\r\nimport { FElement } from './f-element';\r\nimport { Layout } from './layout/layout';\r\n\r\ntype Size = { width: number, height: number };\r\n\r\nexport class FLayout extends FElement {\r\n\r\n\tstatic SAME_DIRECTION: number = 0.50;\r\n\r\n\t#children: FElement[] = [];\r\n\r\n\toverride name(): string {\r\n\t\tconst can = this._typeToCandidate();\r\n\t\treturn can?.name() ?? 'layout';\r\n\t}\r\n\r\n\tadd(child: FElement): void {\r\n\t\tchild.setParent(this);\r\n\t\tthis.#children.push(child);\r\n\t}\r\n\r\n\tchildren(): FElement[] {\r\n\t\treturn this.#children;\r\n\t}\r\n\r\n\tgetDescendantSize(): number {\r\n\t\tlet size: number = this.#children.length;\r\n\r\n\t\tfor (const c of this.#children) {\r\n\t\t\tif (c instanceof FLayout) {\r\n\t\t\t\tsize += c.getDescendantSize();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn size;\r\n\t}\r\n\r\n\r\n\t// -------------------------------------------------------------------------\r\n\r\n\r\n\toverride initializeProblem(p: stlics.Problem): void {\r\n\t\tsuper.initializeProblem(p);\r\n\r\n\t\tfor (let i: number = 0; i < this.#children.length; ++i) {\r\n\t\t\tconst c: FElement = this.#children[i];\r\n\t\t\tc.initializeProblem(p);\r\n\r\n\t\t\tp.createConstraint(\r\n\t\t\t\t(v0: number, v1: number): number => this.#correspondingRelation(i, v0, v1),\r\n\t\t\t\t[this.getVariable(), c.getVariable()],\r\n\t\t\t\tthis.name() + ': toChild',\r\n\t\t\t);\r\n\t\t\tif (c instanceof FLayout) {\r\n\t\t\t\tp.createConstraint(\r\n\t\t\t\t\t(v0: number, v1: number): number => this.#differentDirectionRelation(c, v0, v1),\r\n\t\t\t\t\t[this.getVariable(), c.getVariable()],\r\n\t\t\t\t\tthis.name() + ': toChild',\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t#correspondingRelation(childIndex: number, val1: number, val2: number): number {\r\n\t\tconst s = this._states[val1];\r\n\t\tif (s.comb[childIndex + 1] === val2) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t#differentDirectionRelation(childLayout: FLayout, val1: number, val2: number): number {\r\n\t\tconst pd: number = (this._typeToCandidate(val1) as Layout).getDirection();\r\n\t\tconst cd: number = (childLayout._typeToCandidate(val2) as Layout).getDirection();\r\n\t\tif (pd !== Layout.NO_DIR && cd !== Layout.NO_DIR && pd === cd) {\r\n\t\t\treturn FLayout.SAME_DIRECTION;\r\n\t\t}\r\n\t\treturn 1;\r\n\t}\r\n\r\n\r\n\t// -------------------------------------------------------------------------\r\n\r\n\r\n\tinitializeEstimatedMinimumSize(): void {\r\n\t\tfor (const c of this.#children) {\r\n\t\t\tc.initializeEstimatedMinimumSize();\r\n\t\t}\r\n\t\tlet width: number  = Number.MAX_SAFE_INTEGER;\r\n\t\tlet height: number = Number.MAX_SAFE_INTEGER;\r\n\r\n\t\tfor (const can of this._cans) {\r\n\t\t\tconst d: Size = (can as Layout).getEstimatedMinimumSize(this.#children);\r\n\t\t\twidth  = Math.min(width, d.width);\r\n\t\t\theight = Math.min(height, d.height);\r\n\t\t}\r\n\t\tthis._estMinSize = { width, height };\r\n\t}\r\n\r\n\tinitializeDomain(p: stlics.Problem): boolean {\r\n\t\tfor (const c of this.#children) {\r\n\t\t\tif (!c.initializeDomain(p)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst comb: number[] = new Array(this.#children.length + 1).fill(0);\r\n\t\tconst lens: number[] = new Array(this.#children.length + 1).fill(0);\r\n\r\n\t\tlens[0] = this._cans.length;\r\n\t\tfor (let i: number = 0; i < this.#children.length; ++i) {\r\n\t\t\tlens[i + 1] = this.#children[i]._states.length;\r\n\t\t}\r\n\r\n\t\tlet width: number  = Number.MAX_SAFE_INTEGER;\r\n\t\tlet height: number = Number.MAX_SAFE_INTEGER;\r\n\r\n\t\tthis._states.length = 0;\r\n\r\n\t\tdo {  // Try assigning a value and check the size.\r\n\t\t\tfor (let i: number = 0; i < this.#children.length; ++i) {\r\n\t\t\t\tconst c: FElement = this.#children[i];\r\n\t\t\t\tc.getVariable().assign(comb[i + 1]);\r\n\t\t\t}\r\n\t\t\tconst size = this._cans[comb[0]].getMinimumSize(this.#children);\r\n\r\n\t\t\tif (this.getParent().checkGivenMaximumSize(this, size)) {\r\n\t\t\t\tthis._states.push({ comb: [...comb], size });\r\n\t\t\t\twidth  = Math.min(width, size.width);\r\n\t\t\t\theight = Math.min(height, size.height);\r\n\t\t\t}\r\n\t\t} while (this.#increment(comb, lens));\r\n\r\n\t\tfor (const c of this.#children) {\r\n\t\t\tc.getVariable().clear();\r\n\t\t}\r\n\t\tthis._estMinSize = { width, height };\r\n\r\n\t\tif (this._states.length === 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tthis.getVariable().domain(p.createDomain(0, this._states.length - 1));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t#increment(comb: number[], lens: number[]): boolean {\r\n\t\tfor (let i: number = 0; i < comb.length; ++i) {\r\n\t\t\tcomb[i]++;\r\n\t\t\tif (comb[i] < lens[i]) break;\r\n\t\t\tif (i === comb.length - 1) return false;\r\n\t\t\tcomb[i] = 0;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tcheckGivenMaximumSize(child: FElement, childMinSize: Size): boolean {\r\n\t\tfor (const lt of this._cans) {\r\n\t\t\tconst min: Size = (lt as Layout).getEstimatedMinimumSizeIf(this.#children, child, childMinSize);\r\n\t\t\tif (this.getParent().checkGivenMaximumSize(this, min)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tsetWorstDegree(deg: number): boolean {\r\n\t\tthis._assignCandidates(deg, this._cans);\r\n\t\tif (this._cans.length === 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tfor (const c of this.#children) {\r\n\t\t\tif (!c.setWorstDegree(deg)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\taddPossibleDegreesTo(dest: Set<number>): void {\r\n\t\tfor (const can of this._baseCans) {\r\n\t\t\tdest.add(can.getDegree());\r\n\t\t}\r\n\t\tfor (const c of this.#children) {\r\n\t\t\tc.addPossibleDegreesTo(dest);\r\n\t\t}\r\n\t\tdest.add(FLayout.SAME_DIRECTION);\r\n\t}\r\n\r\n\r\n\t// -------------------------------------------------------------------------\r\n\r\n\r\n\tdoLayout(): void {\r\n\t\tconst can = this._typeToCandidate() as Layout;\r\n\t\tcan.doLayout(this.#children, this.getSize());\r\n\t}\r\n\r\n}\r\n", "import { FElement } from '../f-element';\r\nimport { FLayout } from '../f-layout';\r\nimport { Layout } from './layout';\r\n\r\ntype Size = { width: number, height: number };\r\n\r\nexport class HorizontalArray extends Layout {\r\n\r\n\tconstructor(owner: any, deg: number) {\r\n\t\tsuper(owner, deg, Layout.HORIZONTAL);\r\n\t}\r\n\r\n\toverride name(): string {\r\n\t\treturn 'horizontal array';\r\n\t}\r\n\r\n\t_calcSize(ss: Size[]): Size {\r\n\t\tlet width: number  = 0;\r\n\t\tlet height: number = 0;\r\n\r\n\t\tfor (const s of ss) {\r\n\t\t\twidth += s.width;\r\n\t\t\tif (height < s.height) {\r\n\t\t\t\theight = s.height;\r\n\t\t\t}\r\n\t\t}\r\n\t\twidth  += (ss.length - 1) * 1 + 2;\r\n\t\theight += 2;\r\n\t\treturn { width, height };\r\n\t}\r\n\r\n\tdoLayout(children: FElement[], size: Size): void {\r\n\t\tlet x: number = 1;\r\n\r\n\t\tfor (const fe of children) {\r\n\t\t\tconst min: Size = fe.getMinimumSize();\r\n\t\t\tconst max: Size = fe.getMaximumSize();\r\n\t\t\tfe.setSize(min.width, Math.min(size.height - 2, max.height));\r\n\t\t\tfe.setLocation(x, 1);\r\n\r\n\t\t\tif (fe instanceof FLayout) {\r\n\t\t\t\tfe.doLayout();\r\n\t\t\t}\r\n\t\t\tx += fe.getSize().width + 1;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n", "import { FElement } from '../f-element';\r\nimport { FLayout } from '../f-layout';\r\nimport { Layout } from './layout';\r\n\r\ntype Size = { width: number, height: number };\r\n\r\nexport class VerticalArray extends Layout {\r\n\r\n\tconstructor(owner: any, deg: number) {\r\n\t\tsuper(owner, deg, Layout.VERTICAL);\r\n\t}\r\n\r\n\toverride name(): string {\r\n\t\treturn 'vertical array';\r\n\t}\r\n\r\n\t_calcSize(ss: Size[]): Size {\r\n\t\tlet width: number  = 0;\r\n\t\tlet height: number = 0;\r\n\r\n\t\tfor (const s of ss) {\r\n\t\t\tif (width < s.width) {\r\n\t\t\t\twidth = s.width;\r\n\t\t\t}\r\n\t\t\theight += s.height;\r\n\t\t}\r\n\t\twidth  += 2;\r\n\t\theight += (ss.length - 1) * 1 + 2;\r\n\t\treturn { width, height };\r\n\t}\r\n\r\n\tdoLayout(children: FElement[], size: Size): void {\r\n\t\tlet y: number = 1;\r\n\r\n\t\tfor (const fe of children) {\r\n\t\t\tconst min: Size = fe.getMinimumSize();\r\n\t\t\tconst max: Size = fe.getMaximumSize();\r\n\t\t\tfe.setSize(Math.min(size.width - 2, max.width), min.height);\r\n\t\t\tfe.setLocation(1, y);\r\n\r\n\t\t\tif (fe instanceof FLayout) {\r\n\t\t\t\tfe.doLayout();\r\n\t\t\t}\r\n\t\t\ty += fe.getSize().height + 1;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n", "import { FElement } from '../f-element';\r\nimport { FLayout } from '../f-layout';\r\nimport { Layout } from './layout';\r\n\r\ntype Size = { width: number, height: number };\r\n\r\nexport class LeftLabeling extends Layout {\r\n\r\n\tconstructor(owner: any, deg: number) {\r\n\t\tsuper(owner, deg, Layout.HORIZONTAL);\r\n\t}\r\n\r\n\toverride name(): string {\r\n\t\treturn 'left labeling';\r\n\t}\r\n\r\n\t_calcSize(ss: Size[]): Size {\r\n\t\tconst width: number  = ss[0].width + 1 + ss[1].width + 2;\r\n\t\tconst height: number = Math.max(ss[0].height, ss[1].height) + 2;\r\n\t\treturn { width, height };\r\n\t}\r\n\r\n\tdoLayout(children: FElement[], size: Size): void {\r\n\t\tconst le: FElement = children[0];\r\n\t\tconst ce: FElement = children[1];\r\n\t\tconst ld: Size = le.getMinimumSize();\r\n\t\tconst cd: Size = ce.getMaximumSize();\r\n\r\n\t\tle.setSize(ld.width, ld.height);\r\n\t\tle.setLocation(1, 1);\r\n\r\n\t\tce.setSize(Math.min(size.width - 2 - (ld.width + 1), cd.width), Math.min(size.height - 2, cd.height));\r\n\t\tce.setLocation(1 + le.getSize().width + 1, 1);\r\n\r\n\t\tif (ce instanceof FLayout) {\r\n\t\t\tce.doLayout();\r\n\t\t}\r\n\t}\r\n\r\n}\r\n", "import { FElement } from '../f-element';\r\nimport { FLayout } from '../f-layout';\r\nimport { Layout } from './layout';\r\n\r\ntype Size = { width: number, height: number };\r\n\r\nexport class TopLabeling extends Layout {\r\n\r\n\t#indent: number = 1;\r\n\r\n\tconstructor(owner: any, deg: number) {\r\n\t\tsuper(owner, deg, Layout.VERTICAL);\r\n\t}\r\n\r\n\toverride name(): string {\r\n\t\treturn 'top labeling';\r\n\t}\r\n\r\n\t_calcSize(ss: Size[]): Size {\r\n\t\tconst width: number  = Math.max(ss[0].width, ss[1].width + this.#indent) + 2;\r\n\t\tconst height: number = ss[0].height + 1 + ss[1].height + 2;\r\n\t\treturn { width, height };\r\n\t}\r\n\r\n\tdoLayout(children: FElement[], size: Size): void {\r\n\t\tconst le: FElement = children[0];\r\n\t\tconst ce: FElement = children[1];\r\n\t\tconst ld: Size = le.getMinimumSize();\r\n\t\tconst cd: Size = ce.getMaximumSize();\r\n\r\n\t\tle.setSize(ld.width, ld.height);\r\n\t\tle.setLocation(1, 1);\r\n\r\n\t\tce.setSize(Math.min(size.width - 2 - this.#indent, cd.width), Math.min(size.height - 2 - (ld.height + 1), cd.height));\r\n\t\tce.setLocation(1 + this.#indent, 1 + le.getSize().height + 1);\r\n\r\n\t\tif (ce instanceof FLayout) {\r\n\t\t\tce.doLayout();\r\n\t\t}\r\n\t}\r\n\r\n}\r\n", "import * as stlics from 'stlics/stlics';\r\nimport { FElement } from './f-element';\r\nimport { Control } from './control/control';\r\n\r\ntype Size = { width: number, height: number };\r\n\r\nexport class FControl extends FElement {\r\n\r\n\toverride name(): string {\r\n\t\tconst can = this._typeToCandidate();\r\n\t\treturn can?.name() ?? 'control';\r\n\t}\r\n\r\n\tinitializeEstimatedMinimumSize(): void {\r\n\t\tlet width: number  = Number.MAX_SAFE_INTEGER;\r\n\t\tlet height: number = Number.MAX_SAFE_INTEGER;\r\n\r\n\t\tfor (const can of this._cans) {\r\n\t\t\tconst d: Size = (can as Control).getMinimumSize();\r\n\t\t\twidth  = Math.min(width, d.width);\r\n\t\t\theight = Math.min(height, d.height);\r\n\t\t}\r\n\t\tthis._estMinSize = { width, height };\r\n\t}\r\n\r\n\tinitializeDomain(p: stlics.Problem): boolean {\r\n\t\tthis._states.length = 0;\r\n\r\n\t\tfor (let i: number = 0; i < this._cans.length; i += 1) {\r\n\t\t\tconst size = (this._cans[i] as Control).getMinimumSize();\r\n\r\n\t\t\tif (this.getParent().checkGivenMaximumSize(this, size)) {\r\n\t\t\t\tthis._states.push({ comb: [i], size });\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this._states.length === 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tthis.getVariable().domain(p.createDomain(0, this._states.length - 1));\r\n\t\treturn true;\r\n\t}\r\n\r\n\tsetWorstDegree(deg: number): boolean {\r\n\t\tthis._assignCandidates(deg, this._cans);\r\n\t\tif (this._cans.length === 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\taddPossibleDegreesTo(dest: Set<number>): void {\r\n\t\tfor (const can of this._baseCans) {\r\n\t\t\t(can as Control).addPossibleDegreesTo(dest);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n", "import { FControl } from './f-control';\r\nimport { Control } from './control/control';\r\nimport { Layout } from './layout/layout';\r\nimport { Label } from './control/label';\r\n\r\nexport class Caption extends FControl {\r\n\r\n\t#longText: string;\r\n\t#shortText: string;\r\n\r\n\tconstructor(longText: string, shortText: string) {\r\n\t\tsuper();\r\n\t\tthis.#longText  = longText;\r\n\t\tthis.#shortText = shortText;\r\n\t}\r\n\r\n\toverride name(): string {\r\n\t\treturn 'caption (' + super.name() + ')';\r\n\t}\r\n\r\n\toverride _getCandidateEntries(): [number, (owner: any) => Layout | Control][] {\r\n\t\treturn [\r\n\t\t\t[1.0, owner => new Label(owner, 1.0, this.#longText)],\r\n\t\t\t[0.8, owner => new Label(owner, 0.8, this.#shortText)],\r\n\t\t];\r\n\t}\r\n\r\n}\r\n", "import { FControl } from './f-control';\r\nimport { Control } from './control/control';\r\nimport { Layout } from './layout/layout';\r\nimport { Checkboxes } from './control/checkboxes';\r\nimport { ListBox } from './control/list-box';\r\n\r\nexport class Multiple extends FControl {\r\n\r\n\t#items: string[];\r\n\r\n\tconstructor(...items: string[]) {\r\n\t\tsuper();\r\n\t\tthis.#items = items;\r\n\t}\r\n\r\n\toverride name(): string {\r\n\t\treturn 'multiple (' + super.name() + ')';\r\n\t}\r\n\r\n\toverride _getCandidateEntries(): [number, (owner: any) => Layout | Control][] {\r\n\t\tconst r: [number, (owner: any) => Layout | Control][] = ListBox.createVariableInstances(0.75, 0.9, this.#items);\r\n\t\tr.push([1.0, owner => new Checkboxes(owner, 1.0, this.#items)]);\r\n\t\treturn r;\r\n\t}\r\n\r\n}\r\n", "import { FControl } from './f-control';\r\nimport { Control } from './control/control';\r\nimport { Layout } from './layout/layout';\r\nimport { ListBox } from './control/list-box';\r\nimport { RadioButtons } from './control/radio-buttons';\r\n\r\nexport class Single extends FControl {\r\n\r\n\t#items: string[];\r\n\r\n\tconstructor(...items: string[]) {\r\n\t\tsuper();\r\n\t\tthis.#items = items;\r\n\t}\r\n\r\n\toverride name(): string {\r\n\t\treturn 'single (' + super.name() + ')';\r\n\t}\r\n\r\n\toverride _getCandidateEntries(): [number, (owner: any) => Layout | Control][] {\r\n\t\tconst r: [number, (owner: any) => Layout | Control][] = ListBox.createVariableInstances(0.75, 0.9, this.#items);\r\n\t\tr.push([1.0, owner => new RadioButtons(owner, 1.0, this.#items)]);\r\n\t\treturn r;\r\n\t}\r\n\r\n}\r\n", "import { FControl } from './f-control';\r\nimport { Control } from './control/control';\r\nimport { Layout } from './layout/layout';\r\nimport { Checkbox } from './control/checkbox';\r\nimport { RadioButtons } from './control/radio-buttons';\r\n\r\nexport class SingleBoolean extends FControl {\r\n\r\n\t#itemTrue: string;\r\n\t#itemFalse: string;\r\n\r\n\tconstructor(itemTrue: string, itemFalse: string) {\r\n\t\tsuper();\r\n\t\tthis.#itemTrue  = itemTrue;\r\n\t\tthis.#itemFalse = itemFalse;\r\n\t}\r\n\r\n\toverride name(): string {\r\n\t\treturn 'single boolean (' + super.name() + ')';\r\n\t}\r\n\r\n\toverride _getCandidateEntries(): [number, (owner: any) => Layout | Control][] {\r\n\t\treturn [\r\n\t\t\t[0.9, owner => new Checkbox(owner, 0.9, this.#itemTrue)],\r\n\t\t\t[1.0, owner => new RadioButtons(owner, 1.0, [this.#itemTrue, this.#itemFalse])],\r\n\t\t];\r\n\t}\r\n\r\n}\r\n", "import { FElement } from './f-element';\r\nimport { FLayout } from './f-layout';\r\nimport { Control } from './control/control';\r\nimport { Layout } from './layout/layout';\r\nimport { HorizontalArray } from './layout/array-horizontal';\r\nimport { VerticalArray } from './layout/array-vertical';\r\n\r\nexport class Group extends FLayout {\r\n\r\n\tconstructor(args: { children: FElement[] }) {\r\n\t\tsuper();\r\n\t\tif (args.children) {\r\n\t\t\tfor (const c of args.children) {\r\n\t\t\t\tthis.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\toverride _getCandidateEntries(): [number, (owner: any) => Layout | Control][] {\r\n\t\treturn [\r\n\t\t\t[0.98, owner => new HorizontalArray(owner, 0.98)],\r\n\t\t\t[1.0,  owner => new VerticalArray(owner, 1.0)],\r\n\t\t];\r\n\t}\r\n\r\n}\r\n", "import { FElement } from './f-element';\r\nimport { FLayout } from './f-layout';\r\nimport { Control } from './control/control';\r\nimport { Layout } from './layout/layout';\r\nimport { LeftLabeling } from './layout/labeling-left';\r\nimport { TopLabeling } from './layout/labeling-top';\r\n\r\nexport class Labeling extends FLayout {\r\n\r\n\tconstructor(e_label: FElement, e_content: FElement) {\r\n\t\tsuper();\r\n\t\tthis.add(e_label);\r\n\t\tthis.add(e_content);\r\n\t}\r\n\r\n\toverride _getCandidateEntries(): [number, (owner: any) => Layout | Control][] {\r\n\t\treturn [\r\n\t\t\t[1.0, owner => new LeftLabeling(owner, 1)],\r\n\t\t\t[0.9, owner => new TopLabeling(owner, 0.9)],\r\n\t\t];\r\n\t}\r\n\r\n}\r\n", "import * as stlics from 'stlics/stlics';\r\nimport { FElement } from './f-element';\r\nimport { FLayout } from './f-layout';\r\n\r\ntype Size = { width: number, height: number };\r\n\r\nexport class FlexibleLayout {\r\n\r\n\tstatic DEBUG: boolean = true;\r\n\r\n\tstatic SORT_BY_DESCENDANT: boolean  = true;\r\n\tstatic SORT_BY_PATH_LENGTH: boolean = true;\r\n\r\n\t#root!: FLayout;\r\n\t#size: Size = { width: 0, height: 0 };\r\n\t#lastDegree: number = 0;\r\n\r\n\tsetRootContainer(cw: FLayout): void {\r\n\t\tthis.#root = cw;\r\n\t\tconst that = this;\r\n\t\tthis.#root.setParent(new class {\r\n\t\t\tcheckGivenMaximumSize(_fe: FElement, size: Size): boolean {\r\n\t\t\t\tconst h: number = that.#size.height;\r\n\t\t\t\tconst w: number = that.#size.width;\r\n\t\t\t\treturn (size.height <= h && size.width <= w);\r\n\t\t\t}\r\n\t\t}() as FLayout);\r\n\t}\r\n\r\n\tgetRootContainer(): FLayout {\r\n\t\treturn this.#root;\r\n\t}\r\n\r\n\tgetLastSatisfactionDegree(): number {\r\n\t\treturn this.#lastDegree;\r\n\t}\r\n\r\n\tlayoutContainer(ts: Size): boolean {\r\n\t\tif (this.#performLayout(ts)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t#performLayout(targetSize: Size): boolean {\r\n\t\tthis.#size = { ...targetSize };\r\n\t\tconst p = new stlics.Problem();\r\n\t\tthis.#root.initializeProblem(p);\r\n\t\tthis.#sortVariablesInBreadthFirstOrder(p);\r\n\r\n\t\tconst pd = new Set<number>();\r\n\t\tthis.#root.addPossibleDegreesTo(pd);\r\n\t\tif (!this.#solveProblem(p, pd)) return false;\r\n\r\n\t\tthis.#root.setSize(this.#size.width, this.#size.height);\r\n\t\tthis.#root.setLocation(0, 0);\r\n\t\tthis.#root.doLayout();\r\n\t\treturn true;\r\n\t}\r\n\r\n\t#solveProblem(p: stlics.Problem, possibleDegrees: Set<number>): boolean {\r\n\t\tlet time: number = 0;\r\n\t\tif (FlexibleLayout.DEBUG) {\r\n\t\t\tconsole.log('\\nsolveProblem - started');\r\n\t\t\ttime = Date.now();\r\n\t\t}\r\n\t\tlet success: boolean = false;\r\n\t\tconst pds: number[] = [...possibleDegrees.values()].sort((a, b) => b - a);\r\n\r\n\t\tfor (const r of pds) {\r\n\t\t\tif (r <= 0) continue;\r\n\t\t\tif (FlexibleLayout.DEBUG) console.log(`\\tIteration in wsd ${r}`);\r\n\t\t\tif (!this.#setWorstDegree(p, r)) continue;\r\n\r\n\t\t\tconst mon = new stlics.Monitor();\r\n\t\t\tmon.setTarget(r);\r\n\t\t\tmon.setTimeLimit(100);\r\n\r\n\t\t\tconst solver = new stlics.FuzzyForwardChecking();\r\n\r\n\t\t\tif (solver.solve(p, mon)) {\r\n\t\t\t\tsuccess = true;\r\n\t\t\t\tthis.#lastDegree = r;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (FlexibleLayout.DEBUG) {\r\n\t\t\tconsole.log(`solveProblem - finished (${success}, wsd = ${p.degree()})\\n`);\r\n\t\t\tconsole.log(`time: ${Date.now() - time}`);\r\n\t\t}\r\n\t\treturn success;\r\n\t}\r\n\r\n\t#setWorstDegree(p: stlics.Problem, worstDesirability: number): boolean {\r\n\t\tconst res: boolean = this.#root.setWorstDegree(worstDesirability);\r\n\t\tif (!res) {\r\n\t\t\tconsole.log('Failure: initializeDomain');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tthis.#root.initializeEstimatedMinimumSize();\r\n\t\tif (!this.#root.initializeDomain(p)) {\r\n\t\t\tconsole.log('Failure: initializeDomain');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t#sortVariablesInBreadthFirstOrder(p: stlics.Problem): void {\r\n\t\tconst lens: number[] = stlics.averagePathLengths(p);\r\n\t\tconst vs: stlics.Variable[] = [this.#root.getVariable()];\r\n\t\tlet ls: FLayout[] = [this.#root];\r\n\r\n\t\twhile (ls.length > 0) {\r\n\t\t\tconst nls: FLayout[] = [];\r\n\r\n\t\t\tfor (const l of ls) {\r\n\t\t\t\tfor (const c of l.children()) {\r\n\t\t\t\t\tif (c instanceof FLayout) {\r\n\t\t\t\t\t\tnls.push(c);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.#sortVariablesInCertainOrder(nls, lens);\r\n\t\t\tfor (const l of nls) {\r\n\t\t\t\tvs.push(l.getVariable());\r\n\t\t\t}\r\n\t\t\tls = nls;\r\n\t\t}\r\n\t\tp.sortVariables((o1: stlics.Variable, o2: stlics.Variable): number => {\r\n\t\t\treturn vs.indexOf(o1) - vs.indexOf(o2);\r\n\t\t});\r\n\t}\r\n\r\n\t#sortVariablesInCertainOrder(ls: FLayout[], lens: number[]): void {\r\n\t\tls.sort((l1: FLayout, l2: FLayout): number => {\r\n\t\t\tif (FlexibleLayout.SORT_BY_DESCENDANT) {\r\n\t\t\t\tconst ds1: number = l1.getDescendantSize();\r\n\t\t\t\tconst ds2: number = l2.getDescendantSize();\r\n\t\t\t\tconst r: number = ds2 - ds1;\r\n\t\t\t\tif (r !== 0) return r;\r\n\t\t\t}\r\n\t\t\tif (FlexibleLayout.SORT_BY_PATH_LENGTH) {\r\n\t\t\t\tconst len1: number = lens[l1.getVariable().index()];\r\n\t\t\t\tconst len2: number = lens[l2.getVariable().index()];\r\n\t\t\t\treturn len2 - len1;\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\t\t});\r\n\t}\r\n\r\n}\r\n"],
  "mappings": "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",
  "names": ["Element", "init_element", "__esmMin", "#index", "#name", "index", "name", "Variable", "init_variable", "__esmMin", "init_element", "_Variable", "Element", "#INVALID", "d", "n", "np", "sn", "index", "c", "xs", "x", "i", "value", "Domain", "DomainArbitrary", "DomainRanged", "init_domain", "__esmMin", "vs_min", "max", "#vs", "vs", "v", "index", "#min", "#max", "min", "Constraint", "Constraint1", "Constraint2", "Constraint3", "ConstraintN", "init_constraint", "__esmMin", "init_element", "Element", "r", "xs", "n", "np", "ev", "sn", "index", "x", "cs", "c", "x1", "x2", "x3", "#vs", "i", "Problem", "init_problem", "__esmMin", "init_variable", "init_domain", "init_constraint", "#fv", "d", "Variable", "#fc", "r", "xs", "Constraint", "#xs", "#cs", "fn", "x", "vs_min", "max", "Domain", "x_d", "value", "name", "relation", "c", "index", "i", "comparator", "v1", "v2", "cs", "n", "cur", "ev", "s", "Monitor", "init_monitor", "__esmMin", "#debugMode", "#debugOutput", "#listener", "#iterLimit", "#timeLimit", "#target", "#sameEvLimit", "#endTime", "#iterCount", "#lastEv", "#sameEvCount", "evaluation", "solution", "str", "count", "msec", "rate", "l", "flag", "fn", "Solver", "init_solver", "__esmMin", "init_monitor", "p", "m", "Monitor", "ret", "Assignment", "init_assignment", "__esmMin", "init_variable", "_Assignment", "#x", "#v", "a_x", "value", "Variable", "rand", "n", "generator", "init_random", "__esmMin", "AssignmentList", "init_assignment_list", "__esmMin", "init_assignment", "init_random", "_AssignmentList", "xs", "al", "#as", "p", "x", "Assignment", "a", "value", "diff", "index", "rand", "init_consistency", "__esmMin", "init_flexible_local_changes", "__esmMin", "init_assignment_list", "init_consistency", "init_solver", "indexOfVariableWithMRV", "xs", "dps", "index", "size", "i", "x", "s", "DomainPruner", "init_domain_pruner", "__esmMin", "_DomainPruner", "#UNPRUNED", "#prunedLvs", "#prunedSize", "level", "init_variables", "__esmMin", "init_variable", "init_relations", "__esmMin", "createRelatedConstraintTable", "pro", "xs", "rct", "j", "i", "averagePathLengths", "p", "ls", "x", "averagePathLength", "getPathLength", "connectedSize", "sum", "length", "baseLength", "xo", "xn", "c", "xi", "init_problems", "__esmMin", "init_problem", "init_variable", "init_variables", "init_relations", "init_full_checking", "__esmMin", "init_assignment_list", "init_domain_pruner", "init_problems", "init_solver", "init_fuzzy_breakout", "__esmMin", "init_assignment_list", "init_solver", "FuzzyForwardChecking", "init_fuzzy_forward_checking", "__esmMin", "init_assignment_list", "init_domain_pruner", "init_problems", "init_solver", "Solver", "#xs", "#rct", "#dps", "#sol", "#minDeg", "#globalRet", "#useMRV", "flag", "createRelatedConstraintTable", "x", "DomainPruner", "AssignmentList", "ret", "#branch", "level", "curDeg", "ev", "indexOfVariableWithMRV", "d", "dp", "i", "n", "deg", "#getWorstDegreeAround", "#checkForward", "x_i", "cs", "#getConstraintsBetween", "dp_i", "d_i", "c", "#checkForwardConsistency", "j", "min", "init_fuzzy_genet", "__esmMin", "init_assignment_list", "init_random", "init_solver", "init_srs3", "__esmMin", "init_assignment_list", "init_random", "init_solver", "init_breakout", "__esmMin", "init_assignment_list", "init_solver", "init_crisp_srs3", "__esmMin", "init_assignment_list", "init_random", "init_solver", "init_forward_checking", "__esmMin", "init_assignment_list", "init_domain_pruner", "init_problems", "init_solver", "init_genet", "__esmMin", "init_assignment_list", "init_random", "init_solver", "init_local_changes", "__esmMin", "init_assignment_list", "init_solver", "init_max_forward_checking", "__esmMin", "init_assignment_list", "init_domain_pruner", "init_problems", "init_solver", "Control", "#degree", "#minSize", "#maxSize", "owner", "degree", "dest", "s", "Button", "Control", "#text", "owner", "deg", "text", "s", "Checkbox", "Control", "#text", "owner", "deg", "text", "s", "Checkboxes", "Control", "#items", "owner", "deg", "items", "maxLen", "it", "s", "Label", "Control", "#text", "owner", "deg", "text", "s", "ListBox", "_ListBox", "Control", "#items", "minDeg", "maxDeg", "items", "owner", "ret", "rDeg", "i", "r", "count", "deg", "minH", "maxLen", "it", "RadioButtons", "Control", "#items", "owner", "deg", "items", "maxLen", "it", "s", "Layout", "_Layout", "#owner", "#degree", "#direction", "owner", "degree", "direction", "children", "ss", "e", "child", "minSize", "init_problem", "init_element", "init_variable", "init_domain", "init_constraint", "init_solver", "init_monitor", "init_flexible_local_changes", "init_full_checking", "init_fuzzy_breakout", "init_fuzzy_forward_checking", "init_fuzzy_genet", "init_srs3", "init_breakout", "init_crisp_srs3", "init_forward_checking", "init_genet", "init_local_changes", "init_max_forward_checking", "init_assignment_list", "init_solver", "init_assignment", "init_assignment_list", "init_consistency", "init_domain_pruner", "init_random", "init_problems", "init_variables", "init_relations", "FElement", "#parent", "#type", "#size", "#location", "parent", "worstDeg", "dest", "d", "e", "p", "Domain", "v0", "#typeRelation", "val", "width", "height", "x", "y", "FLayout", "_FLayout", "FElement", "#children", "child", "size", "c", "p", "i", "v0", "v1", "#correspondingRelation", "#differentDirectionRelation", "childIndex", "val1", "val2", "childLayout", "pd", "cd", "Layout", "width", "height", "can", "d", "comb", "lens", "#increment", "childMinSize", "lt", "min", "deg", "dest", "HorizontalArray", "Layout", "owner", "deg", "ss", "width", "height", "s", "children", "size", "x", "fe", "min", "max", "FLayout", "VerticalArray", "Layout", "owner", "deg", "ss", "width", "height", "s", "children", "size", "y", "fe", "min", "max", "FLayout", "LeftLabeling", "Layout", "owner", "deg", "ss", "width", "height", "children", "size", "le", "ce", "ld", "cd", "FLayout", "TopLabeling", "Layout", "#indent", "owner", "deg", "ss", "width", "height", "children", "size", "le", "ce", "ld", "cd", "FLayout", "FControl", "FElement", "width", "height", "can", "d", "p", "i", "size", "deg", "dest", "Caption", "FControl", "#longText", "#shortText", "longText", "shortText", "owner", "Label", "Multiple", "FControl", "#items", "items", "r", "ListBox", "owner", "Checkboxes", "Single", "FControl", "#items", "items", "r", "ListBox", "owner", "RadioButtons", "SingleBoolean", "FControl", "#itemTrue", "#itemFalse", "itemTrue", "itemFalse", "owner", "Checkbox", "RadioButtons", "Group", "FLayout", "args", "c", "owner", "HorizontalArray", "VerticalArray", "Labeling", "FLayout", "e_label", "e_content", "owner", "LeftLabeling", "TopLabeling", "FlexibleLayout", "_FlexibleLayout", "#root", "#size", "#lastDegree", "cw", "that", "_fe", "size", "h", "w", "ts", "#performLayout", "targetSize", "p", "Problem", "#sortVariablesInBreadthFirstOrder", "pd", "#solveProblem", "possibleDegrees", "time", "success", "pds", "a", "b", "r", "#setWorstDegree", "mon", "Monitor", "FuzzyForwardChecking", "worstDesirability", "lens", "averagePathLengths", "vs", "ls", "nls", "l", "c", "FLayout", "#sortVariablesInCertainOrder", "o1", "o2", "l1", "l2", "ds1", "len1"]
}
