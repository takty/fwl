class Control{#t;#e={width:0,height:0};#i={width:Number.MAX_SAFE_INTEGER,height:Number.MAX_SAFE_INTEGER};_owner;constructor(t,e){this._owner=t,this.#t=e}getDegree(){return this.#t}addPossibleDegreesTo(t){t.add(this.#t)}setMinimumSize(t){this.#e={...t}}getMinimumSize(){return{...this.#e}}setMaximumSize(t){this.#i={...t}}getMaximumSize(){return{...this.#i}}}class Button extends Control{#s;constructor(t,e,i){super(t,e),this.#s=i;const s={width:this.#s.length+2,height:2};this.setMinimumSize(s),this.setMaximumSize(s)}name(){return"button"}}class Checkbox extends Control{#s;constructor(t,e,i){super(t,e),this.#s=i;const s={width:this.#s.length+2,height:1};this.setMinimumSize(s),this.setMaximumSize(s)}name(){return"checkbox"}}class Checkboxes extends Control{#n;constructor(t,e,i){super(t,e),this.#n=[...i];let s=0;for(const t of i)s=Math.max(s,t.length);const n={width:s+1,height:1*i.length};this.setMinimumSize(n),this.setMaximumSize(n)}name(){return"checkboxes"}}class Label extends Control{#s;constructor(t,e,i){super(t,e),this.#s=i;const s={width:this.#s.length,height:1};this.setMinimumSize(s),this.setMaximumSize(s)}name(){return"label"}}class ListBox extends Control{static MIN_ITEM_SIZE=4;#n;static createVariableInstances(t,e,i){if(i.length<=ListBox.MIN_ITEM_SIZE)return[[e,t=>new ListBox(t,e,i,ListBox.MIN_ITEM_SIZE)]];const s=[],n=e-t;for(let t=ListBox.MIN_ITEM_SIZE+1;t<i.length;++t){const r=e+n*(t/i.length-1),a=t;s.push([r,t=>new ListBox(t,r,i,a)])}return s}constructor(t,e,i,s=i.length){super(t,e),this.#n=[...i];const n=1*Math.min(s,ListBox.MIN_ITEM_SIZE);let r=0;for(const t of i)r=Math.max(r,t.length);this.setMinimumSize({width:r+1,height:n}),this.setMaximumSize({width:Number.MAX_SAFE_INTEGER,height:Number.MAX_SAFE_INTEGER})}name(){return"list box"}}class RadioButtons extends Control{#n;constructor(t,e,i){super(t,e),this.#n=[...i];let s=0;for(const t of i)s=Math.max(s,t.length);const n={width:s+1,height:1*i.length};this.setMinimumSize(n),this.setMaximumSize(n)}name(){return"radio buttons"}}class Layout{static NO_DIR=-1;static VERTICAL=0;static HORIZONTAL=1;#r;#t;#a;constructor(t,e,i=Layout.NO_DIR){this.#r=t,this.#t=e,this.#a=i}getOwner(){return this.#r}getDegree(){return this.#t}getDirection(){return this.#a}getEstimatedMinimumSize(t){const e=t.map((t=>t.getEstimatedMinimumSize()));return this._calcSize(e)}getEstimatedMinimumSizeIf(t,e,i){const s=t.map((t=>e===t?i:t.getEstimatedMinimumSize()));return this._calcSize(s)}getMinimumSize(t){const e=t.map((t=>t.getMinimumSize(t)));return this._calcSize(e)}getMaximumSize(){return{width:Number.MAX_SAFE_INTEGER,height:Number.MAX_SAFE_INTEGER}}}class HorizontalArray extends Layout{constructor(t,e){super(t,e,Layout.HORIZONTAL)}name(){return"horizontal array"}_calcSize(t){let e=0,i=0;for(const s of t)e+=s.width,i<s.height&&(i=s.height);return e+=1*(t.length-1)+2,i+=2,{width:e,height:i}}doLayout(t,e){let i=1;for(const s of t){const t=s.getMinimumSize(),n=s.getMaximumSize();s.setSize(t.width,Math.min(e.height-2,n.height)),s.setLocation(i,1),s instanceof FLayout&&s.doLayout(),i+=s.getSize().width+1}}}class VerticalArray extends Layout{constructor(t,e){super(t,e,Layout.VERTICAL)}name(){return"vertical array"}_calcSize(t){let e=0,i=0;for(const s of t)e<s.width&&(e=s.width),i+=s.height;return e+=2,i+=1*(t.length-1)+2,{width:e,height:i}}doLayout(t,e){let i=1;for(const s of t){const t=s.getMinimumSize(),n=s.getMaximumSize();s.setSize(Math.min(e.width-2,n.width),t.height),s.setLocation(1,i),s instanceof FLayout&&s.doLayout(),i+=s.getSize().height+1}}}class LeftLabeling extends Layout{constructor(t,e){super(t,e,Layout.HORIZONTAL)}name(){return"left labeling"}_calcSize(t){return{width:t[0].width+1+t[1].width+2,height:Math.max(t[0].height,t[1].height)+2}}doLayout(t,e){const i=t[0],s=t[1],n=i.getMinimumSize(),r=s.getMaximumSize();i.setSize(n.width,n.height),i.setLocation(1,1),s.setSize(Math.min(e.width-2-(n.width+1),r.width),Math.min(e.height-2,r.height)),s.setLocation(1+i.getSize().width+1,1),s instanceof FLayout&&s.doLayout()}}class TopLabeling extends Layout{#o=1;constructor(t,e){super(t,e,Layout.VERTICAL)}name(){return"top labeling"}_calcSize(t){return{width:Math.max(t[0].width,t[1].width+this.#o)+2,height:t[0].height+1+t[1].height+2}}doLayout(t,e){const i=t[0],s=t[1],n=i.getMinimumSize(),r=s.getMaximumSize();i.setSize(n.width,n.height),i.setLocation(1,1),s.setSize(Math.min(e.width-2-this.#o,r.width),Math.min(e.height-2-(n.height+1),r.height)),s.setLocation(1+this.#o,1+i.getSize().height+1),s instanceof FLayout&&s.doLayout()}}class FElement{#h=null;#l=null;#c={width:0,height:0};#u={x:0,y:0};_estMinSize={width:Number.MAX_SAFE_INTEGER,height:Number.MAX_SAFE_INTEGER};_states=[];_cans=[];_baseCans=[];name(){return""}setParent(t){this.#h=t}getParent(){return this.#h}getVariable(){return this.#l}getEstimatedMinimumSize(){return{...this._estMinSize}}_getCandidateEntries(){return[]}_assignCandidates(t,e){e.length=0;for(const[i,s]of this._getCandidateEntries())t<=i&&e.push(s(this))}initializeProblem(t){this._assignCandidates(0,this._cans),this._baseCans=[...this._cans],this.#l=t.createVariable({name:this.name()+": type"}),t.createConstraint({name:this.name()+": type",relation:new FuzzyRelationFunction(((...t)=>this.#m(...t))),variables:[this.#l]})}#m(t){if(0===this._states.length)return FuzzyRelation.MIN_SATISFACTION_DEGREE;return this._typeToCandidate(t).getDegree()}_typeToCandidate(t=null){return null===t&&this.#l&&(t=this.#l.value()),this._states[t]?this._cans[this._states[t].comb[0]]:null}isValid(){return!(!this.#l||this.#l.isEmpty())&&!!this._states[this.#l.value()]}getMinimumSize(){return{...this._states[this.#l.value()].size}}getMaximumSize(){return this._typeToCandidate().getMaximumSize()}getSize(){return{...this.#c}}setSize(t,e){this.#c={width:t,height:e}}getLocation(){return{...this.#u}}setLocation(t,e){this.#u={x:t,y:e}}}class FControl extends FElement{name(){const t=this._typeToCandidate();return t?.name()??"control"}initializeEstimatedMinimumSize(){let t=Number.MAX_SAFE_INTEGER,e=Number.MAX_SAFE_INTEGER;for(const i of this._cans){const s=i.getMinimumSize();t=Math.min(t,s.width),e=Math.min(e,s.height)}this._estMinSize={width:t,height:e}}initializeDomain(t){this._states.length=0;for(let t=0;t<this._cans.length;t+=1){const e=this._cans[t].getMinimumSize();this.getParent().checkGivenMaximumSize(this,e)&&this._states.push({comb:[t],size:e})}return 0!==this._states.length&&(this.getVariable().setDomain(t.createDomain({min:0,max:this._states.length-1})),!0)}setWorstDegree(t){return this._assignCandidates(t,this._cans),0!==this._cans.length}addPossibleDegreesTo(t){for(const e of this._baseCans)e.addPossibleDegreesTo(t)}}class Caption extends FControl{#d;#g;constructor(t,e){super(),this.#d=t,this.#g=e}name(){return"caption ("+super.name()+")"}_getCandidateEntries(){return[[1,t=>new Label(t,1,this.#d)],[.8,t=>new Label(t,.8,this.#g)]]}}class Multiple extends FControl{#n;constructor(...t){super(),this.#n=t}name(){return"multiple ("+super.name()+")"}_getCandidateEntries(){const t=ListBox.createVariableInstances(.75,.9,this.#n);return t.push([1,t=>new Checkboxes(t,1,this.#n)]),t}}class Single extends FControl{#n;constructor(...t){super(),this.#n=t}name(){return"single ("+super.name()+")"}_getCandidateEntries(){const t=ListBox.createVariableInstances(.75,.9,this.#n);return t.push([1,t=>new RadioButtons(t,1,this.#n)]),t}}class SingleBoolean extends FControl{#_;#z;constructor(t,e){super(),this.#_=t,this.#z=e}name(){return"single boolean ("+super.name()+")"}_getCandidateEntries(){return[[.9,t=>new Checkbox(t,.9,this.#_)],[1,t=>new RadioButtons(t,1,[this.#_,this.#z])]]}}class FLayout extends FElement{static SAME_DIRECTION=.5;#S=[];name(){const t=this._typeToCandidate();return t?.name()??"layout"}add(t){t.setParent(this),this.#S.push(t)}children(){return this.#S}getDescendantSize(){let t=this.#S.length;for(const e of this.#S)e instanceof FLayout&&(t+=e.getDescendantSize());return t}initializeProblem(t){super.initializeProblem(t);for(let e=0;e<this.#S.length;++e){const i=this.#S[e];i.initializeProblem(t),t.createConstraint({name:this.name()+": toChild",relation:new FuzzyRelationFunction(((...t)=>this.#E(e,...t))),variables:[this.getVariable(),i.getVariable()]}),i instanceof FLayout&&t.createConstraint({name:this.name()+": toChild",relation:new FuzzyRelationFunction(((...t)=>this.#M(i,...t))),variables:[this.getVariable(),i.getVariable()]})}}#E(t,e,i){return this._states[e].comb[t+1]===i?FuzzyRelation.MAX_SATISFACTION_DEGREE:FuzzyRelation.MIN_SATISFACTION_DEGREE}#M(t,e,i){const s=this._typeToCandidate(e).getDirection(),n=t._typeToCandidate(i).getDirection();return s!==Layout.NO_DIR&&n!==Layout.NO_DIR&&s===n?FLayout.SAME_DIRECTION:FuzzyRelation.MAX_SATISFACTION_DEGREE}initializeEstimatedMinimumSize(){for(const t of this.#S)t.initializeEstimatedMinimumSize();let t=Number.MAX_SAFE_INTEGER,e=Number.MAX_SAFE_INTEGER;for(const i of this._cans){const s=i.getEstimatedMinimumSize(this.#S);t=Math.min(t,s.width),e=Math.min(e,s.height)}this._estMinSize={width:t,height:e}}initializeDomain(t){for(const e of this.#S)if(!e.initializeDomain(t))return!1;const e=new Array(this.#S.length+1).fill(0),i=new Array(this.#S.length+1).fill(0);i[0]=this._cans.length;for(let t=0;t<this.#S.length;++t)i[t+1]=this.#S[t]._states.length;let s=Number.MAX_SAFE_INTEGER,n=Number.MAX_SAFE_INTEGER;this._states.length=0;do{for(let t=0;t<this.#S.length;++t){this.#S[t].getVariable().assign(e[t+1])}const t=this._cans[e[0]].getMinimumSize(this.#S);this.getParent().checkGivenMaximumSize(this,t)&&(this._states.push({comb:[...e],size:t}),s=Math.min(s,t.width),n=Math.min(n,t.height))}while(this.#f(e,i));for(const t of this.#S)t.getVariable().clear();return this._estMinSize={width:s,height:n},0!==this._states.length&&(this.getVariable().setDomain(t.createDomain({min:0,max:this._states.length-1})),!0)}#f(t,e){for(let i=0;i<t.length&&(t[i]++,!(t[i]<e[i]));++i){if(i===t.length-1)return!1;t[i]=0}return!0}checkGivenMaximumSize(t,e){for(const i of this._cans){const s=i.getEstimatedMinimumSizeIf(this.#S,t,e);if(this.getParent().checkGivenMaximumSize(this,s))return!0}return!1}setWorstDegree(t){if(this._assignCandidates(t,this._cans),0===this._cans.length)return!1;for(const e of this.#S)if(!e.setWorstDegree(t))return!1;return!0}addPossibleDegreesTo(t){for(const e of this._baseCans)t.add(e.getDegree());for(const e of this.#S)e.addPossibleDegreesTo(t);t.add(FLayout.SAME_DIRECTION)}doLayout(){this._typeToCandidate().doLayout(this.#S,this.getSize())}}class Group extends FLayout{constructor(t){if(super(),t.children)for(const e of t.children)this.add(e)}_getCandidateEntries(){return[[.98,t=>new HorizontalArray(t,.98)],[1,t=>new VerticalArray(t,1)]]}}class Labeling extends FLayout{constructor(t,e){super(),this.add(t),this.add(e)}_getCandidateEntries(){return[[1,t=>new LeftLabeling(t,1)],[.9,t=>new TopLabeling(t,.9)]]}}class FlexibleLayout{static DEBUG=!0;static SORT_BY_DESCENDANT=!0;static SORT_BY_PATH_LENGTH=!0;#b;#c={width:0,height:0};#x;setRootContainer(t){this.#b=t;const e=this;this.#b.setParent(new class{checkGivenMaximumSize(t,i){const s=e.#c.height,n=e.#c.width;return i.height<=s&&i.width<=n}})}getRootContainer(){return this.#b}getLastSatisfactionDegree(){return this.#x}layoutContainer(t){return!!this.#y(t)}#y(t){this.#c={...t};const e=new Problem;this.#b.initializeProblem(e),this.#L(e);const i=new Set;return this.#b.addPossibleDegreesTo(i),!!this.#w(e,i)&&(this.#b.setSize(this.#c.width,this.#c.height),this.#b.setLocation(0,0),this.#b.doLayout(),!0)}#w(t,e){let i=0;FlexibleLayout.DEBUG&&(console.log("\nsolveProblem - started"),i=Date.now());let s=!1;const n=[...e.values()].sort(((t,e)=>e-t));for(const e of n){if(e<=0)continue;if(FlexibleLayout.DEBUG&&console.log(`\tIteration in wsd ${e}`),!this.#T(t,e))continue;const i=new FuzzyForwardChecking(t);if(i.setTargetRate(e),i.solve()){s=!0,this.#x=e;break}}return FlexibleLayout.DEBUG&&(console.log(`solveProblem - finished (${s}, wsd = ${t.worstSatisfactionDegree()})\n`),console.log("time: "+(Date.now()-i))),s}#T(t,e){return this.#b.setWorstDegree(e)?(this.#b.initializeEstimatedMinimumSize(),!!this.#b.initializeDomain(t)||(console.log("Failure: initializeDomain"),!1)):(console.log("Failure: initializeDomain"),!1)}#L(t){const e=Problems.averagePathLengths(t),i=[this.#b.getVariable()];let s=[this.#b];for(;s.length>0;){const t=[];for(const e of s)for(const i of e.children())i instanceof FLayout&&t.push(i);this.#p(t,e);for(const e of t)i.push(e.getVariable());s=t}t.sortVariables(((t,e)=>i.indexOf(t)-i.indexOf(e)))}#p(t,e){t.sort(((t,i)=>{if(FlexibleLayout.SORT_BY_DESCENDANT){const e=t.getDescendantSize(),s=i.getDescendantSize()-e;if(0!==s)return s}if(FlexibleLayout.SORT_BY_PATH_LENGTH){const s=e[t.getVariable().index()];return e[i.getVariable().index()]-s}return 0}))}}
//# sourceMappingURL=fwl.min.js.map